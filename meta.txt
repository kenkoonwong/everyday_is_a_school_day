c(0, 5, 21, 2, 0, 215)
c(50, 48, 250, 459, 109, 4177)
0.5
only0
TRUE
CP
c(0.5, 0, 0, 0, 0.5, 0)
c("bayliff 1999", "pobble 2005", "mavs 2006", "dipom 2006", "bbsa 2007", "poise 2008")
PLOGIT
NA
c(-4.61512051684126, -2.15176220325946, -2.38919956583082, -5.43153621033426, -5.3890717298165, -2.91386619913083)
c(1.4211973755246, 0.472499538574895, 0.228004078573437, 0.708652371623379, 1.41743868300937, 0.070025428021521)
c(NA, NA, NA, NA, NA, NA)
c(NA, NA, NA, NA, NA, NA)
c(NA, NA, NA, NA, NA, NA)
0.95
c(0, 0.034698122121196, 0.052749149986262, 0.000528125343707768, 0, 0.0449675391095331)
c(0.0711217364641976, 0.226577661283764, 0.125536827373125, 0.0156507318133586, 0.0332766647985084, 0.0586131047428945)
FALSE
NULL
6
6
6
6
TRUE
TRUE
TRUE
TRUE
FALSE
TRUE
TRUE
NULL
NULL
NULL
NULL
GLMM
GLMM
c(NA, NA, NA, NA, NA, NA)
-2.99367254055738
0.065737190466712
-45.5400134886098
NA
0.95
-3.12251506631698
-2.86483001479777
c(NA, NA, NA, NA, NA, NA)
-3.98321221538343
0.786991537927107
-5.06131517738424
NA
classic
Inf
-5.52568728585835
-2.44073714490851
0.534268450315715

NA
NA
NA
NA
NA
HTS

NA
1.76894410060802
4
0.95
-8.89458840488507
0.928163974118209
NA
NA
c(Wald = 20.204707412439, LRT = 56.4490254004094)
c(5, 5)
c(0.00114386456629603, 6.56784938424704e-11)
ML
NULL

2.50980755030703
NA
NA
NA
1.58423721402669
NA
NA
NULL
NULL



2.01020931310344
1.33717198491759
3.02200579137684
0.752532917308085
0.440724928800994
0.890501185964257
NA
NA
NA
Egger
Common effect model
Random effects model
Prediction interval
common
random







FALSE
list(study = c("bayliff 1999", "pobble 2005", "mavs 2006", "dipom 2006", "bbsa 2007", "poise 2008"), event.c = c(0, 5, 21, 2, 0, 215), n.c = c(50, 48, 250, 459, 109, 4177), .event = c(0, 5, 21, 2, 0, 215), .n = c(50, 48, 250, 459, 109, 4177), .studlab = c("bayliff 1999", "pobble 2005", "mavs 2006", "dipom 2006", "bbsa 2007", "poise 2008"), .incr = c(0.5, 0.5, 0.5, 0.5, 0.5, 0.5))
NULL
NULL
NULL
TRUE
metaprop(event = event.c, n = n.c, studlab = study, data = df1, method.tau = "ML")
6.5-0
list(tau2.calc = 1.21613350120418, m4 = NULL)
c(NA, NA, NA, NA, NA, NA)
FALSE
-45.5400134886098
-5.06131517738424
c(NA, NA, NA, NA, NA, NA)
-2.99367254055738
0.065737190466712
-3.12251506631698
-2.86483001479777
-45.5400134886098
NA
-45.5400134886098
Common effect model
common
NA
NA
NA
list(b = -2.99367254055738, beta = -2.99367254055738, se = 0.065737190466712, zval = -45.5400134886098, pval = 0, ci.lb = -3.12251506631698, ci.ub = -2.86483001479777, vb = 0.00432137821045678, tau2 = 0, se.tau2 = NA, sigma2 = NA, rho = NA, ci.lb.tau2 = NA, ci.ub.tau2 = NA, I2 = 0, H2 = 1, vt = 0.10288701378041, QE.Wld = 20.204707412439, QEp.Wld = 0.00114386456629603, QE.LRT = 56.4490254004094, QEp.LRT = 6.56784938424704e-11, QE.df = 5, QM = 2073.89282854276, QMdf = c(1, NA), QMp = 0, k = 6, k.f = 6, 
    k.yi = 6, k.eff = 6, k.all = 6, p = 1, p.eff = 1, parms = 1, int.only = TRUE, int.incl = TRUE, intercept = TRUE, yi = c(-4.61512051684126, -2.15176220325946, -2.38919956583082, -5.43153621033426, -5.3890717298165, -2.91386619913083), vi = c(2.01980198019802, 0.223255813953488, 0.0519858598461218, 0.50218818380744, 2.00913242009132, 0.00490356056959722), X = c(1, 1, 1, 1, 1, 1), yi.f = c(-4.61512051684126, -2.15176220325946, -2.38919956583082, -5.43153621033426, -5.3890717298165, -2.91386619913083
    ), vi.f = c(2.01980198019802, 0.223255813953488, 0.0519858598461218, 0.50218818380744, 2.00913242009132, 0.00490356056959722), X.f = c(1, 1, 1, 1, 1, 1), outdat.f = list(ai = NA, bi = NA, ci = NA, di = NA, x1i = NA, x2i = NA, t1i = NA, t2i = NA, xi = c(0, 5, 21, 2, 0, 215), mi = c(50, 43, 229, 457, 109, 3962), ni = c(50, 48, 250, 459, 109, 4177), ti = NA), outdat = list(ai = NA, bi = NA, ci = NA, di = NA, x1i = NA, x2i = NA, t1i = NA, t2i = NA, xi = c(0, 5, 21, 2, 0, 215), mi = c(50, 43, 229, 
    457, 109, 3962), ti = NA), ni = c(50, 48, 250, 459, 109, 4177), ni.f = c(50, 48, 250, 459, 109, 4177), ids = 1:6, not.na = c(TRUE, TRUE, TRUE, TRUE, TRUE, TRUE), subset = NULL, not.na.yivi = c(TRUE, TRUE, TRUE, TRUE, TRUE, TRUE), slab = 1:6, slab.null = TRUE, measure = "PLO", method = "FE", model = "UM.FS", weighted = TRUE, test = "z", dfs = NA, ddf = NA, btt = 1, m = 1, digits = c(est = 4, se = 4, test = 4, pval = 4, ci = 4, var = 4, sevar = 4, fit = 4, het = 4), level = 0.05, control = list(), 
    verbose = FALSE, add = 0.5, to = "only0", drop00 = TRUE, fit.stats = list(ML = c(-37.1942393761115, 56.4490254004094, 76.388478752223, 76.180238221451, 77.388478752223), REML = c(NA, NA, NA, NA, NA)), data = <environment>, se.warn = FALSE, formula.yi = NULL, formula.mods = NULL, version = list(c(4, 4, 0)), call = (function (ai, bi, ci, di, n1i, n2i, x1i, x2i, t1i, t2i, xi, mi, ti, ni, mods, measure, intercept = TRUE, data, slab, subset, add = 1/2, to = "only0", drop00 = TRUE, vtype = "LS", model = "UM.FS", 
        method = "ML", coding = 1/2, cor = FALSE, test = "z", level = 95, btt, nAGQ = 7, verbose = FALSE, digits, control, ...) 
    {
        mstyle <- .get.mstyle("crayon" %in% .packages())
        if (missing(measure)) 
            stop(mstyle$stop("Must specify 'measure' argument."))
        if (!is.element(measure, c("OR", "IRR", "PLO", "IRLN", "PR", "RR", "RD", "PLN"))) 
            stop(mstyle$stop("Unknown 'measure' specified."))
        if (!is.element(method, c("FE", "EE", "CE", "ML"))) 
            stop(mstyle$stop("Unknown 'method' specified."))
        if (!is.element(coding, c(1/2, 1, 0))) 
            stop(mstyle$stop("Unknown 'coding' option specified."))
        if (length(add) > 1) 
            add <- add[1]
        if (length(to) > 1) 
            to <- to[1]
        if (!is.element(model, c("UM.FS", "UM.RS", "CM.EL", "CM.AL"))) 
            stop(mstyle$stop("Unknown 'model' specified."))
        if (model == "CM.AL" && measure == "IRR") 
            model <- "CM.EL"
        if (is.element(measure, c("PLO", "PR", "PLN", "IRLN")) && !is.null(match.call()$model)) 
            warning(mstyle$warning("Argument 'model' not relevant for this outcome measure."), call. = FALSE)
        if (!is.element(measure, c("OR", "IRR", "PLO", "IRLN"))) 
            warning(mstyle$warning("The use of this 'measure' is experimental - treat results with caution."), call. = FALSE)
        if (is.element(model, c("CM.EL", "CM.AL")) && is.element(measure, c("RR", "RD"))) 
            stop(mstyle$stop("Cannot use this measure with model='CM.EL' or model='CM.AL'."))
        na.act <- getOption("na.action")
        on.exit(options(na.action = na.act), add = TRUE)
        if (!is.element(na.act, c("na.omit", "na.exclude", "na.fail", "na.pass"))) 
            stop(mstyle$stop("Unknown 'na.action' specified under options()."))
        if (missing(control)) 
            control <- list()
        time.start <- proc.time()
        ddd <- list(...)
        .chkdots(ddd, c("tdist", "outlist", "onlyo1", "addyi", "addvi", "time", "retdat", "family", "retfit", "skiphet", "i2def", "link"))
        if (.isFALSE(ddd$tdist)) 
            test <- "z"
        if (.isTRUE(ddd$tdist)) 
            test <- "t"
        if (!is.element(test, c("z", "t"))) 
            stop(mstyle$stop("Invalid option selected for 'test' argument."))
        onlyo1 <- ifelse(is.null(ddd$onlyo1), FALSE, ddd$onlyo1)
        addyi <- ifelse(is.null(ddd$addyi), TRUE, ddd$addyi)
        addvi <- ifelse(is.null(ddd$addvi), TRUE, ddd$addvi)
        i2def <- ifelse(is.null(ddd$i2def), "1", ddd$i2def)
        if (missing(digits)) {
            digits <- .set.digits(dmiss = TRUE)
        }
        else {
            digits <- .set.digits(digits, dmiss = FALSE)
        }
        formula.mods <- NULL
        if (verbose > 2) {
            opwarn <- options(warn = 1)
            on.exit(options(warn = opwarn$warn), add = TRUE)
        }
        if (is.null(ddd$link)) {
            if (measure == "OR" || measure == "PLO") 
                link <- "logit"
            if (measure == "RR" || measure == "PLN") 
                link <- "log"
            if (measure == "RD" || measure == "PR") 
                link <- "identity"
            if (measure == "IRR" || measure == "IRLN") 
                link <- "log"
        }
        else {
            link <- ddd$link
        }
        if (verbose) 
            .space()
        if (verbose > 1) 
            message(mstyle$message("Extracting data and computing yi/vi values ..."))
        if (missing(data)) 
            data <- NULL
        if (is.null(data)) {
            data <- sys.frame(sys.parent())
        }
        else {
            if (!is.data.frame(data)) 
                data <- data.frame(data)
        }
        mf <- match.call()
        slab <- .getx("slab", mf = mf, data = data)
        subset <- .getx("subset", mf = mf, data = data)
        mods <- .getx("mods", mf = mf, data = data)
        ai <- bi <- ci <- di <- x1i <- x2i <- t1i <- t2i <- xi <- mi <- ti <- NA
        if (is.element(measure, c("OR", "RR", "RD"))) {
            ai <- .getx("ai", mf = mf, data = data, checknumeric = TRUE)
            bi <- .getx("bi", mf = mf, data = data, checknumeric = TRUE)
            ci <- .getx("ci", mf = mf, data = data, checknumeric = TRUE)
            di <- .getx("di", mf = mf, data = data, checknumeric = TRUE)
            n1i <- .getx("n1i", mf = mf, data = data, checknumeric = TRUE)
            n2i <- .getx("n2i", mf = mf, data = data, checknumeric = TRUE)
            if (is.null(bi)) 
                bi <- n1i - ai
            if (is.null(di)) 
                di <- n2i - ci
            k <- length(ai)
            k.all <- k
            if (!is.null(subset)) {
                subset <- .chksubset(subset, k)
                ai <- .getsubset(ai, subset)
                bi <- .getsubset(bi, subset)
                ci <- .getsubset(ci, subset)
                di <- .getsubset(di, subset)
            }
            args <- list(measure = measure, ai = ai, bi = bi, ci = ci, di = di, add = add, to = to, drop00 = drop00, vtype = vtype, onlyo1 = onlyo1, addyi = addyi, addvi = addvi)
        }
        if (is.element(measure, c("IRR"))) {
            x1i <- .getx("x1i", mf = mf, data = data, checknumeric = TRUE)
            x2i <- .getx("x2i", mf = mf, data = data, checknumeric = TRUE)
            t1i <- .getx("t1i", mf = mf, data = data, checknumeric = TRUE)
            t2i <- .getx("t2i", mf = mf, data = data, checknumeric = TRUE)
            k <- length(x1i)
            k.all <- k
            if (!is.null(subset)) {
                subset <- .chksubset(subset, k)
                x1i <- .getsubset(x1i, subset)
                x2i <- .getsubset(x2i, subset)
                t1i <- .getsubset(t1i, subset)
                t2i <- .getsubset(t2i, subset)
            }
            args <- list(measure = measure, x1i = x1i, x2i = x2i, t1i = t1i, t2i = t2i, add = add, to = to, drop00 = drop00, vtype = vtype, onlyo1 = onlyo1, addyi = addyi, addvi = addvi)
        }
        if (is.element(measure, c("PLO", "PR", "PLN"))) {
            xi <- .getx("xi", mf = mf, data = data, checknumeric = TRUE)
            mi <- .getx("mi", mf = mf, data = data, checknumeric = TRUE)
            ni <- .getx("ni", mf = mf, data = data, checknumeric = TRUE)
            if (is.null(mi)) 
                mi <- ni - xi
            k <- length(xi)
            k.all <- k
            if (!is.null(subset)) {
                subset <- .chksubset(subset, k)
                xi <- .getsubset(xi, subset)
                mi <- .getsubset(mi, subset)
            }
            args <- list(measure = measure, xi = xi, mi = mi, add = add, to = to, vtype = vtype, onlyo1 = onlyo1, addyi = addyi, addvi = addvi)
        }
        if (is.element(measure, c("IRLN"))) {
            xi <- .getx("xi", mf = mf, data = data, checknumeric = TRUE)
            ti <- .getx("ti", mf = mf, data = data, checknumeric = TRUE)
            k <- length(xi)
            k.all <- k
            if (!is.null(subset)) {
                subset <- .chksubset(subset, k)
                xi <- .getsubset(xi, subset)
                ti <- .getsubset(ti, subset)
            }
            args <- list(measure = measure, xi = xi, ti = ti, add = add, to = to, vtype = vtype, onlyo1 = onlyo1, addyi = addyi, addvi = addvi)
        }
        dat <- .do.call(escalc, args)
        yi <- dat$yi
        vi <- dat$vi
        ni <- attr(yi, "ni")
        ids <- seq_len(k)
        if (verbose > 1) 
            message(mstyle$message("Creating model matrix ..."))
        if (inherits(mods, "formula")) {
            formula.mods <- mods
            if (isTRUE(all.equal(formula.mods, ~1))) {
                mods <- matrix(1, nrow = k, ncol = 1)
                intercept <- FALSE
            }
            else {
                options(na.action = "na.pass")
                mods <- model.matrix(mods, data = data)
                attr(mods, "assign") <- NULL
                options(na.action = na.act)
                intercept <- FALSE
            }
        }
        if (.is.vector(mods)) 
            mods <- cbind(mods)
        if (is.data.frame(mods)) 
            mods <- as.matrix(mods)
        if (is.character(mods)) 
            stop(mstyle$stop("Model matrix contains character variables."))
        if (!is.null(mods) && nrow(mods) != k) 
            stop(mstyle$stop(paste0("Number of rows in the model matrix (", nrow(mods), ") does not match length of the outcome vector (", k, ").")))
        if (verbose > 1) 
            message(mstyle$message("Generating/extracting study labels ..."))
        if (is.null(slab)) {
            slab.null <- TRUE
            slab <- ids
        }
        else {
            if (anyNA(slab)) 
                stop(mstyle$stop("NAs in study labels."))
            if (length(slab) != k) 
                stop(mstyle$stop("Study labels not of same length as data."))
            if (is.factor(slab)) 
                slab <- as.character(slab)
            slab.null <- FALSE
        }
        if (!is.null(subset)) {
            if (verbose > 1) 
                message(mstyle$message("Subsetting ..."))
            mods <- .getsubset(mods, subset)
            slab <- .getsubset(slab, subset)
            ids <- .getsubset(ids, subset)
        }
        if (anyDuplicated(slab)) 
            slab <- .make.unique(slab)
        attr(yi, "slab") <- slab
        k <- length(yi)
        if (is.element(measure, c("OR", "RR", "RD"))) {
            if (drop00) {
                id00 <- c(ai == 0 & ci == 0) | c(bi == 0 & di == 0)
                id00[is.na(id00)] <- FALSE
                ai[id00] <- NA
                bi[id00] <- NA
                ci[id00] <- NA
                di[id00] <- NA
            }
        }
        if (is.element(measure, c("IRR"))) {
            if (drop00) {
                id00 <- c(x1i == 0 & x2i == 0)
                id00[is.na(id00)] <- FALSE
                x1i[id00] <- NA
                x2i[id00] <- NA
            }
        }
        outdat.f <- list(ai = ai, bi = bi, ci = ci, di = di, x1i = x1i, x2i = x2i, t1i = t1i, t2i = t2i, xi = xi, mi = mi, ni = ni, ti = ti)
        yi.f <- yi
        vi.f <- vi
        ni.f <- ni
        mods.f <- mods
        k.f <- k
        if (is.element(measure, c("OR", "RR", "RD"))) {
            has.na <- is.na(ai) | is.na(bi) | is.na(ci) | is.na(di) | (if (is.null(mods)) 
                FALSE
            else apply(is.na(mods), 1, any))
            not.na <- !has.na
            if (any(has.na)) {
                if (verbose > 1) 
                  message(mstyle$message("Handling NAs in table data ..."))
                if (na.act == "na.omit" || na.act == "na.exclude" || na.act == "na.pass") {
                  ai <- ai[not.na]
                  bi <- bi[not.na]
                  ci <- ci[not.na]
                  di <- di[not.na]
                  mods <- mods[not.na, , drop = FALSE]
                  k <- length(ai)
                  warning(mstyle$warning(paste(sum(has.na), ifelse(sum(has.na) > 1, "studies", "study"), "with NAs omitted from model fitting.")), call. = FALSE)
                }
                if (na.act == "na.fail") 
                  stop(mstyle$stop("Missing values in studies."))
            }
        }
        if (is.element(measure, "IRR")) {
            has.na <- is.na(x1i) | is.na(x2i) | is.na(t1i) | is.na(t2i) | (if (is.null(mods)) 
                FALSE
            else apply(is.na(mods), 1, any))
            not.na <- !has.na
            if (any(has.na)) {
                if (verbose > 1) 
                  message(mstyle$message("Handling NAs in table data ..."))
                if (na.act == "na.omit" || na.act == "na.exclude" || na.act == "na.pass") {
                  x1i <- x1i[not.na]
                  x2i <- x2i[not.na]
                  t1i <- t1i[not.na]
                  t2i <- t2i[not.na]
                  mods <- mods[not.na, , drop = FALSE]
                  k <- length(x1i)
                  warning(mstyle$warning(paste(sum(has.na), ifelse(sum(has.na) > 1, "studies", "study"), "with NAs omitted from model fitting.")), call. = FALSE)
                }
                if (na.act == "na.fail") 
                  stop(mstyle$stop("Missing values in studies."))
            }
        }
        if (is.element(measure, c("PLO", "PR", "PLN"))) {
            has.na <- is.na(xi) | is.na(mi) | (if (is.null(mods)) 
                FALSE
            else apply(is.na(mods), 1, any))
            not.na <- !has.na
            if (any(has.na)) {
                if (verbose > 1) 
                  message(mstyle$message("Handling NAs in table data ..."))
                if (na.act == "na.omit" || na.act == "na.exclude" || na.act == "na.pass") {
                  xi <- xi[not.na]
                  mi <- mi[not.na]
                  mods <- mods[not.na, , drop = FALSE]
                  k <- length(xi)
                  warning(mstyle$warning(paste(sum(has.na), ifelse(sum(has.na) > 1, "studies", "study"), "with NAs omitted from model fitting.")), call. = FALSE)
                }
                if (na.act == "na.fail") 
                  stop(mstyle$stop("Missing values in studies."))
            }
        }
        if (is.element(measure, "IRLN")) {
            has.na <- is.na(xi) | is.na(ti) | (if (is.null(mods)) 
                FALSE
            else apply(is.na(mods), 1, any))
            not.na <- !has.na
            if (any(has.na)) {
                if (verbose > 1) 
                  message(mstyle$message("Handling NAs in table data ..."))
                if (na.act == "na.omit" || na.act == "na.exclude" || na.act == "na.pass") {
                  xi <- xi[not.na]
                  ti <- ti[not.na]
                  mods <- mods[not.na, , drop = FALSE]
                  k <- length(xi)
                  warning(mstyle$warning(paste(sum(has.na), ifelse(sum(has.na) > 1, "studies", "study"), "with NAs omitted from model fitting.")), call. = FALSE)
                }
                if (na.act == "na.fail") 
                  stop(mstyle$stop("Missing values in studies."))
            }
        }
        if (k < 1) 
            stop(mstyle$stop("Processing terminated since k = 0."))
        mods.yi <- mods.f
        yivi.na <- is.na(yi) | is.na(vi) | (if (is.null(mods.yi)) 
            FALSE
        else apply(is.na(mods.yi), 1, any))
        not.na.yivi <- !yivi.na
        if (any(yivi.na)) {
            if (verbose > 1) 
                message(mstyle$message("Handling NAs in yi/vi ..."))
            if (na.act == "na.omit" || na.act == "na.exclude" || na.act == "na.pass") {
                yi <- yi[not.na.yivi]
                ni <- ni[not.na.yivi]
                vi <- vi[not.na.yivi]
                mods.yi <- mods.f[not.na.yivi, , drop = FALSE]
                warning(mstyle$warning("Some yi/vi values are NA."), call. = FALSE)
                attr(yi, "measure") <- measure
                attr(yi, "ni") <- ni
            }
            if (na.act == "na.fail") 
                stop(mstyle$stop("Missing yi/vi values."))
        }
        k.yi <- length(yi)
        if (is.null(mods) && !intercept) {
            warning(mstyle$warning("Must either include an intercept and/or moderators in model.\nCoerced intercept into the model."), call. = FALSE)
            intercept <- TRUE
        }
        if (!is.null(mods) && ncol(mods) == 0) {
            warning(mstyle$warning("Cannot fit model with an empty model matrix. Coerced intercept into the model."), call. = FALSE)
            intercept <- TRUE
        }
        if (intercept) {
            X <- cbind(intrcpt = rep(1, k), mods)
            X.f <- cbind(intrcpt = rep(1, k.f), mods.f)
            X.yi <- cbind(intrcpt = rep(1, k.yi), mods.yi)
        }
        else {
            X <- mods
            X.f <- mods.f
            X.yi <- mods.yi
        }
        tmp <- lm(rep(0, k) ~ X - 1)
        coef.na <- is.na(coef(tmp))
        if (any(coef.na)) {
            warning(mstyle$warning("Redundant predictors dropped from the model."), call. = FALSE)
            X <- X[, !coef.na, drop = FALSE]
            X.f <- X.f[, !coef.na, drop = FALSE]
        }
        tmp <- lm(yi ~ X.yi - 1)
        coef.na <- is.na(coef(tmp))
        if (any(coef.na)) 
            X.yi <- X.yi[, !coef.na, drop = FALSE]
        is.int <- apply(X, 2, .is.intercept)
        if (any(is.int)) {
            int.incl <- TRUE
            int.indx <- which(is.int, arr.ind = TRUE)
            X <- cbind(intrcpt = 1, X[, -int.indx, drop = FALSE])
            X.f <- cbind(intrcpt = 1, X.f[, -int.indx, drop = FALSE])
            intercept <- TRUE
        }
        else {
            int.incl <- FALSE
        }
        is.int <- apply(X.yi, 2, .is.intercept)
        if (any(is.int)) {
            int.indx <- which(is.int, arr.ind = TRUE)
            X.yi <- cbind(intrcpt = 1, X.yi[, -int.indx, drop = FALSE])
        }
        p <- NCOL(X)
        colnames(X) <- colnames(X.f) <- .make.unique(colnames(X))
        if ((p == 1) && .is.intercept(X)) {
            int.only <- TRUE
        }
        else {
            int.only <- FALSE
        }
        if (is.element(method, c("FE", "EE", "CE")) && p > k) 
            stop(mstyle$stop("Number of parameters to be estimated is larger than the number of observations."))
        if (!is.element(method, c("FE", "EE", "CE")) && (p + 1) > k) 
            stop(mstyle$stop("Number of parameters to be estimated is larger than the number of observations."))
        btt <- .set.btt(btt, p, int.incl, colnames(X))
        m <- length(btt)
        con <- list(verbose = FALSE, package = "lme4", optimizer = "nlminb", optmethod = "BFGS", parallel = list(), cl = NULL, ncpus = 1, scaleX = TRUE, evtol = 1e-07, dnchgcalc = "dFNCHypergeo", dnchgprec = 1e-10, hesspack = "numDeriv", tau2tol = 1e-04)
        con.pos <- pmatch(names(control), names(con))
        con[c(na.omit(con.pos))] <- control[!is.na(con.pos)]
        if (verbose) 
            con$verbose <- verbose
        verbose <- con$verbose
        optimizer <- match.arg(con$optimizer, c("optim", "nlminb", "uobyqa", "newuoa", "bobyqa", "nloptr", "nlm", "hjk", "nmk", "mads", "ucminf", "lbfgsb3c", "subplex", "BBoptim", "optimParallel", "clogit", "clogistic", "Nelder-Mead", "BFGS", "CG", "L-BFGS-B", "SANN", "Brent", "Rcgmin", "Rvmmin"))
        optmethod <- match.arg(con$optmethod, c("Nelder-Mead", "BFGS", "CG", "L-BFGS-B", "SANN", "Brent"))
        if (optimizer %in% c("Nelder-Mead", "BFGS", "CG", "L-BFGS-B", "SANN", "Brent")) {
            optmethod <- optimizer
            optimizer <- "optim"
        }
        package <- match.arg(con$package, c("lme4", "GLMMadaptive", "glmmTMB"))
        parallel <- con$parallel
        cl <- con$cl
        ncpus <- con$ncpus
        if (con$dnchgcalc != "dnoncenhypergeom" && con$dnchgcalc != "dFNCHypergeo") 
            stop(mstyle$stop("Unknown dnchgcalc method specified."))
        if (is.element(optimizer, c("clogit", "clogistic")) && method == "ML") 
            stop(mstyle$stop("Cannot use 'clogit' or 'clogistic' with method='ML'."))
        if (package == "lme4" && is.element(measure, c("OR", "RR", "RD", "IRR")) && model == "UM.RS" && method == "ML" && nAGQ > 1) {
            warning(mstyle$warning("Not possible to fit RE/ME model='UM.RS' with nAGQ > 1 with glmer(). nAGQ automatically set to 1."), call. = FALSE)
            nAGQ <- 1
        }
        if (ncpus > 1) 
            optimizer <- "optimParallel"
        pos.optCtrl <- pmatch(names(control), "optCtrl", nomatch = 0)
        if (sum(pos.optCtrl) > 0) {
            optCtrl <- control[[which(pos.optCtrl == 1)]]
        }
        else {
            optCtrl <- list()
        }
        if (optimizer == "nloptr" && !is.element("algorithm", names(optCtrl))) 
            optCtrl$algorithm <- "NLOPT_LN_BOBYQA"
        if (optimizer == "nloptr" && !is.element("ftol_rel", names(optCtrl))) 
            optCtrl$ftol_rel <- 1e-08
        if (optimizer == "mads" && !is.element("trace", names(optCtrl))) 
            optCtrl$trace <- FALSE
        if (optimizer == "mads" && !is.element("tol", names(optCtrl))) 
            optCtrl$tol <- 1e-06
        if (optimizer == "subplex" && !is.element("reltol", names(optCtrl))) 
            optCtrl$reltol <- 1e-08
        if (optimizer == "BBoptim" && !is.element("trace", names(optCtrl))) 
            optCtrl$trace <- FALSE
        if (optimizer == "optim") {
            con.pos <- pmatch(names(optCtrl), "REPORT", nomatch = 0)
            if (sum(con.pos) > 0) {
                names(optCtrl)[which(con.pos == 1)] <- "REPORT"
            }
            else {
                optCtrl$REPORT <- 1
            }
            optCtrl$trace <- con$verbose
        }
        if (optimizer == "nlminb") 
            optCtrl$trace <- ifelse(con$verbose > 0, 1, 0)
        if (is.element(optimizer, c("uobyqa", "newuoa", "bobyqa"))) 
            optCtrl$iprint <- ifelse(con$verbose > 0, 3, 0)
        pos.clogitCtrl <- pmatch(names(control), "clogitCtrl", nomatch = 0)
        if (sum(pos.clogitCtrl) > 0) {
            clogitCtrl <- control[[which(pos.clogitCtrl == 1)]]
        }
        else {
            clogitCtrl <- list()
        }
        pos.clogisticCtrl <- pmatch(names(control), "clogisticCtrl", nomatch = 0)
        if (sum(pos.clogisticCtrl) > 0) {
            clogisticCtrl <- control[[which(pos.clogisticCtrl == 1)]]
        }
        else {
            clogisticCtrl <- list()
        }
        pos.glmCtrl <- pmatch(names(control), "glmCtrl", nomatch = 0)
        if (sum(pos.glmCtrl) > 0) {
            glmCtrl <- control[[which(pos.glmCtrl == 1)]]
        }
        else {
            glmCtrl <- list()
        }
        glmCtrl$trace <- ifelse(con$verbose > 0, TRUE, FALSE)
        pos.glmerCtrl <- pmatch(names(control), "glmerCtrl", nomatch = 0)
        if (sum(pos.glmerCtrl) > 0) {
            glmerCtrl <- control[[which(pos.glmerCtrl == 1)]]
        }
        else {
            glmerCtrl <- list()
        }
        pos.intCtrl <- pmatch(names(control), "intCtrl", nomatch = 0)
        if (sum(pos.intCtrl) > 0) {
            intCtrl <- control[[which(pos.intCtrl == 1)]]
        }
        else {
            intCtrl <- list()
        }
        con.pos <- pmatch(names(intCtrl), "lower", nomatch = 0)
        if (sum(con.pos) > 0) {
            names(intCtrl)[which(con.pos == 1)] <- "lower"
        }
        else {
            intCtrl$lower <- -Inf
        }
        con.pos <- pmatch(names(intCtrl), "upper", nomatch = 0)
        if (sum(con.pos) > 0) {
            names(intCtrl)[which(con.pos == 1)] <- "upper"
        }
        else {
            intCtrl$upper <- Inf
        }
        con.pos <- pmatch(names(intCtrl), "subdivisions", nomatch = 0)
        if (sum(con.pos) > 0) {
            names(intCtrl)[which(con.pos == 1)] <- "subdivisions"
        }
        else {
            intCtrl$subdivisions <- 100
        }
        con.pos <- pmatch(names(intCtrl), "rel.tol", nomatch = 0)
        if (sum(con.pos) > 0) {
            names(intCtrl)[which(con.pos == 1)] <- "rel.tol"
        }
        else {
            intCtrl$rel.tol <- .Machine$double.eps^0.25
        }
        pos.hessianCtrl <- pmatch(names(control), "hessianCtrl", nomatch = 0)
        if (sum(pos.hessianCtrl) > 0) {
            hessianCtrl <- control[[which(pos.hessianCtrl == 1)]]
        }
        else {
            hessianCtrl <- list(r = 16)
        }
        if (is.element(measure, c("OR", "RR", "RD", "IRR"))) {
            if ((model == "UM.FS" && method == "ML") || (model == "UM.RS") || (model == "CM.AL" && method == "ML") || (model == "CM.EL" && method == "ML")) {
                if (!requireNamespace(package, quietly = TRUE)) 
                  stop(mstyle$stop(paste0("Please install the '", package, "' package to fit this model.")))
            }
        }
        if (is.element(measure, c("PLO", "PR", "PLN", "IRLN")) && method == "ML") {
            if (!requireNamespace(package, quietly = TRUE)) 
                stop(mstyle$stop(paste0("Please install the '", package, "' package to fit this model.")))
        }
        if (measure == "OR" && model == "CM.EL") {
            if (is.element(optimizer, c("uobyqa", "newuoa", "bobyqa"))) {
                if (!requireNamespace("minqa", quietly = TRUE)) 
                  stop(mstyle$stop("Please install the 'minqa' package to fit this model."))
            }
            if (is.element(optimizer, c("nloptr", "ucminf", "lbfgsb3c", "subplex", "optimParallel"))) {
                if (!requireNamespace(optimizer, quietly = TRUE)) 
                  stop(mstyle$stop(paste0("Please install the '", optimizer, "' package to use this optimizer.")))
            }
            if (is.element(optimizer, c("hjk", "nmk", "mads"))) {
                if (!requireNamespace("dfoptim", quietly = TRUE)) 
                  stop(mstyle$stop("Please install the 'dfoptim' package to use this optimizer."))
            }
            if (optimizer == "BBoptim") {
                if (!requireNamespace("BB", quietly = TRUE)) 
                  stop(mstyle$stop("Please install the 'BB' package to use this optimizer."))
            }
            if (is.element(optimizer, c("optim", "nlminb", "uobyqa", "newuoa", "bobyqa", "nloptr", "nlm", "hjk", "nmk", "mads", "ucminf", "lbfgsb3c", "subplex", "BBoptim", "optimParallel", "Rcgmin", "Rvmmin"))) {
                con$hesspack <- match.arg(con$hesspack, c("numDeriv", "pracma"))
                if (!requireNamespace(con$hesspack, quietly = TRUE)) 
                  stop(mstyle$stop(paste0("Please install the '", con$hesspack, "' package to fit this model.")))
                if (con$dnchgcalc == "dFNCHypergeo") {
                  if (!requireNamespace("BiasedUrn", quietly = TRUE)) 
                    stop(mstyle$stop("Please install the 'BiasedUrn' package to fit this model."))
                }
            }
            if (optimizer == "clogit") {
                if (!requireNamespace("survival", quietly = TRUE)) 
                  stop(mstyle$stop("Please install the 'survival' package to fit this model."))
                coxph <- survival::coxph
                Surv <- survival::Surv
                clogit <- survival::clogit
                strata <- survival::strata
            }
            if (optimizer == "clogistic") {
                if (!requireNamespace("Epi", quietly = TRUE)) 
                  stop(mstyle$stop("Please install the 'Epi' package to fit this model."))
            }
        }
        if (!.chkpd(crossprod(X), tol = con$evtol)) 
            stop(mstyle$stop("Model matrix not of full rank. Cannot fit model."))
        se.tau2 <- ci.lb.tau2 <- ci.ub.tau2 <- I2 <- H2 <- QE <- QEp <- NA
        se.warn <- FALSE
        rho <- NA
        level <- .level(level)
        if (!int.only && int.incl && con$scaleX) {
            Xsave <- X
            meanX <- colMeans(X[, 2:p, drop = FALSE])
            sdX <- apply(X[, 2:p, drop = FALSE], 2, sd)
            is.d <- apply(X, 2, .is.dummy)
            X[, !is.d] <- apply(X[, !is.d, drop = FALSE], 2, scale)
        }
        if (is.element(measure, c("OR", "RR", "RD", "IRR"))) {
            if (is.element(model, c("UM.FS", "UM.RS"))) {
                if (is.element(measure, c("OR", "RR", "RD"))) {
                  dat.grp <- cbind(xi = c(rbind(ai, ci)), mi = c(rbind(bi, di)))
                  if (is.null(ddd$family)) {
                    if (measure == "OR") 
                      dat.fam <- binomial(link = link)
                    if (measure == "RR") 
                      dat.fam <- binomial(link = link)
                    if (measure == "RD") 
                      dat.fam <- binomial(link = link)
                  }
                  else {
                    dat.fam <- ddd$family
                  }
                  dat.off <- NULL
                }
                if (is.element(measure, c("IRR"))) {
                  dat.grp <- c(rbind(x1i, x2i))
                  if (is.null(ddd$family)) {
                    dat.fam <- poisson(link = link)
                  }
                  else {
                    dat.fam <- ddd$family
                  }
                  dat.off <- log(c(rbind(t1i, t2i)))
                }
                group1 <- rep(c(1, 0), times = k)
                group2 <- rep(c(0, 1), times = k)
                group12 <- rep(c(1/2, -1/2), times = k)
                study <- factor(rep(seq_len(k), each = 2))
                const <- cbind(rep(1, 2 * k))
                X.fit <- X[rep(seq(k), each = 2), , drop = FALSE]
                X.fit <- cbind(group1 * X.fit[, , drop = FALSE])
                if (coding == 1/2) 
                  group <- group12
                if (coding == 1) 
                  group <- group1
                if (coding == 0) 
                  group <- group2
                rownames(X.fit) <- seq_len(2 * k)
                if (.isTRUE(ddd$retdat)) 
                  return(list(dat.grp = dat.grp, X.fit = X.fit, study = study, dat.off = if (!is.null(dat.off)) dat.off else NULL, const = const, group1 = group1, group2 = group2, group12 = group12, group = group, dat.fam = dat.fam))
                if (model == "UM.FS") {
                  if (verbose) 
                    message(mstyle$message("Fitting FE model ..."))
                  if (k > 1) {
                    res.FE <- try(glm(dat.grp ~ -1 + X.fit + study, offset = dat.off, family = dat.fam, control = glmCtrl), silent = !verbose)
                  }
                  else {
                    res.FE <- try(glm(dat.grp ~ -1 + X.fit + const, offset = dat.off, family = dat.fam, control = glmCtrl), silent = !verbose)
                  }
                  if (inherits(res.FE, "try-error")) 
                    stop(mstyle$stop(paste0("Cannot fit FE model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))))
                  ll.FE <- c(logLik(res.FE))
                  QEconv <- FALSE
                  ll.QE <- NA
                  if (!isTRUE(ddd$skiphet)) {
                    if (k > 1 && verbose) 
                      message(mstyle$message("Fitting saturated model ..."))
                    if (k > 1) {
                      X.QE <- model.matrix(~-1 + X.fit + study + study:group1)
                      res.QE <- try(glm(dat.grp ~ -1 + X.QE, offset = dat.off, family = dat.fam, control = glmCtrl), silent = !verbose)
                    }
                    else {
                      res.QE <- res.FE
                    }
                    if (inherits(res.QE, "try-error")) {
                      warning(mstyle$warning(paste0("Cannot fit saturated model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))), call. = FALSE)
                    }
                    else {
                      QEconv <- TRUE
                      ll.QE <- c(logLik(res.QE))
                      b2.QE <- cbind(coef(res.QE, complete = FALSE)[-seq_len(k + p)])
                      vb2.QE <- vcov(res.QE, complete = FALSE)[-seq_len(k + p), -seq_len(k + p), drop = FALSE]
                    }
                  }
                  if (method == "ML") {
                    if (verbose) 
                      message(mstyle$message("Fitting ML model ..."))
                    if (package == "lme4") {
                      if (verbose) {
                        res.ML <- try(lme4::glmer(dat.grp ~ -1 + X.fit + study + (group - 1 | study), offset = dat.off, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = do.call(lme4::glmerControl, glmerCtrl)), silent = !verbose)
                      }
                      else {
                        res.ML <- suppressMessages(try(lme4::glmer(dat.grp ~ -1 + X.fit + study + (group - 1 | study), offset = dat.off, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = do.call(lme4::glmerControl, glmerCtrl)), silent = !verbose))
                      }
                    }
                    if (package == "GLMMadaptive") {
                      if (is.element(measure, c("OR", "RR", "RD"))) {
                        dat.mm <- data.frame(xi = dat.grp[, "xi"], mi = dat.grp[, "mi"], study = study, group = group)
                        res.ML <- try(GLMMadaptive::mixed_model(cbind(xi, mi) ~ -1 + X.fit + study, random = ~group - 1 | study, data = dat.mm, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = glmerCtrl), silent = !verbose)
                      }
                      else {
                        dat.mm <- data.frame(xi = dat.grp, study = study, group = group)
                        res.ML <- try(GLMMadaptive::mixed_model(xi ~ -1 + X.fit + study + offset(dat.off), random = ~group - 1 | study, data = dat.mm, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = glmerCtrl), silent = !verbose)
                      }
                    }
                    if (package == "glmmTMB") {
                      if (verbose) {
                        res.ML <- try(glmmTMB::glmmTMB(dat.grp ~ -1 + X.fit + study + (group - 1 | study), offset = dat.off, family = dat.fam, verbose = verbose, data = NULL, control = do.call(glmmTMB::glmmTMBControl, glmerCtrl)), silent = !verbose)
                      }
                      else {
                        res.ML <- suppressMessages(try(glmmTMB::glmmTMB(dat.grp ~ -1 + X.fit + study + (group - 1 | study), offset = dat.off, family = dat.fam, verbose = verbose, data = NULL, control = do.call(glmmTMB::glmmTMBControl, glmerCtrl)), silent = !verbose))
                      }
                    }
                    if (inherits(res.ML, "try-error")) 
                      stop(mstyle$stop(paste0("Cannot fit ML model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))))
                    if (package == "lme4") {
                      if (is.na(ll.QE)) {
                        ll.ML <- c(logLik(res.ML))
                      }
                      else {
                        ll.ML <- ll.QE - 1/2 * deviance(res.ML)
                      }
                    }
                    else {
                      ll.ML <- c(logLik(res.ML))
                    }
                  }
                  if (is.element(method, c("FE", "EE", "CE"))) {
                    beta <- cbind(coef(res.FE)[seq_len(p)])
                    vb <- vcov(res.FE)[seq_len(p), seq_len(p), drop = FALSE]
                    tau2 <- 0
                    sigma2 <- NA
                    parms <- p + k
                    p.eff <- p + k
                    k.eff <- 2 * k
                  }
                  if (method == "ML") {
                    if (package == "lme4") {
                      beta <- cbind(lme4::fixef(res.ML)[seq_len(p)])
                      vb <- as.matrix(vcov(res.ML))[seq_len(p), seq_len(p), drop = FALSE]
                      tau2 <- lme4::VarCorr(res.ML)[[1]][1]
                    }
                    if (package == "GLMMadaptive") {
                      beta <- cbind(GLMMadaptive::fixef(res.ML)[seq_len(p)])
                      vb <- as.matrix(vcov(res.ML))[seq_len(p), seq_len(p), drop = FALSE]
                      tau2 <- res.ML$D[1, 1]
                    }
                    if (package == "glmmTMB") {
                      beta <- cbind(glmmTMB::fixef(res.ML)$cond[seq_len(p)])
                      vb <- as.matrix(vcov(res.ML)$cond)[seq_len(p), seq_len(p), drop = FALSE]
                      tau2 <- glmmTMB::VarCorr(res.ML)[[1]][[1]][[1]]
                    }
                    sigma2 <- NA
                    parms <- p + k + 1
                    p.eff <- p + k
                    k.eff <- 2 * k
                  }
                }
                if (model == "UM.RS") {
                  if (verbose) 
                    message(mstyle$message("Fitting FE model ..."))
                  if (package == "lme4") {
                    if (verbose) {
                      res.FE <- try(lme4::glmer(dat.grp ~ -1 + X.fit + const + (1 | study), offset = dat.off, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = do.call(lme4::glmerControl, glmerCtrl)), silent = !verbose)
                    }
                    else {
                      res.FE <- suppressMessages(try(lme4::glmer(dat.grp ~ -1 + X.fit + const + (1 | study), offset = dat.off, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = do.call(lme4::glmerControl, glmerCtrl)), silent = !verbose))
                    }
                  }
                  if (package == "GLMMadaptive") {
                    if (is.element(measure, c("OR", "RR", "RD"))) {
                      dat.mm <- data.frame(xi = dat.grp[, "xi"], mi = dat.grp[, "mi"], study = study, const = const)
                      res.FE <- try(GLMMadaptive::mixed_model(cbind(xi, mi) ~ -1 + X.fit + const, random = ~1 | study, data = dat.mm, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = glmerCtrl), silent = !verbose)
                    }
                    else {
                      dat.mm <- data.frame(xi = dat.grp, study = study, const = const)
                      res.FE <- try(GLMMadaptive::mixed_model(xi ~ -1 + X.fit + const + offset(dat.off), random = ~1 | study, data = dat.mm, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = glmerCtrl), silent = !verbose)
                    }
                  }
                  if (package == "glmmTMB") {
                    if (verbose) {
                      res.FE <- try(glmmTMB::glmmTMB(dat.grp ~ -1 + X.fit + const + (1 | study), offset = dat.off, family = dat.fam, verbose = verbose, data = NULL, control = do.call(glmmTMB::glmmTMBControl, glmerCtrl)), silent = !verbose)
                    }
                    else {
                      res.FE <- suppressMessages(try(glmmTMB::glmmTMB(dat.grp ~ -1 + X.fit + const + (1 | study), offset = dat.off, family = dat.fam, verbose = verbose, data = NULL, control = do.call(glmmTMB::glmmTMBControl, glmerCtrl)), silent = !verbose))
                    }
                  }
                  if (inherits(res.FE, "try-error")) 
                    stop(mstyle$stop(paste0("Cannot fit FE model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))))
                  ll.FE <- c(logLik(res.FE))
                  QEconv <- FALSE
                  ll.QE <- NA
                  if (!isTRUE(ddd$skiphet)) {
                    if (k > 1 && verbose) 
                      message(mstyle$message("Fitting saturated model ..."))
                    if (k > 1) {
                      X.QE <- model.matrix(~-1 + X.fit + const + study:group1)
                      res.QE <- try(glm(dat.grp ~ -1 + X.QE, offset = dat.off, family = dat.fam, control = glmCtrl), silent = TRUE)
                      X.QE <- X.QE[, !is.na(coef(res.QE)), drop = FALSE]
                      if (package == "lme4") {
                        if (verbose) {
                          res.QE <- try(lme4::glmer(dat.grp ~ -1 + X.QE + (1 | study), offset = dat.off, family = dat.fam, start = c(sqrt(lme4::VarCorr(res.FE)[[1]][1])), nAGQ = nAGQ, verbose = verbose, control = do.call(lme4::glmerControl, glmerCtrl)), silent = !verbose)
                        }
                        else {
                          res.QE <- suppressMessages(try(lme4::glmer(dat.grp ~ -1 + X.QE + (1 | study), offset = dat.off, family = dat.fam, start = c(sqrt(lme4::VarCorr(res.FE)[[1]][1])), nAGQ = nAGQ, verbose = verbose, control = do.call(lme4::glmerControl, glmerCtrl)), silent = !verbose))
                        }
                      }
                      if (package == "GLMMadaptive") {
                        glmerCtrl$max_coef_value <- 50
                        if (is.element(measure, c("OR", "RR", "RD"))) {
                          dat.mm <- data.frame(xi = dat.grp[, "xi"], mi = dat.grp[, "mi"], study = study)
                          res.QE <- try(GLMMadaptive::mixed_model(cbind(xi, mi) ~ -1 + X.QE, random = ~1 | study, data = dat.mm, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = glmerCtrl, initial_values = list(D = matrix(res.FE$D[1, 1]))), silent = !verbose)
                        }
                        else {
                          dat.mm <- data.frame(xi = dat.grp, study = study)
                          res.QE <- try(GLMMadaptive::mixed_model(xi ~ -1 + X.QE + offset(dat.off), random = ~1 | study, data = dat.mm, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = glmerCtrl), silent = !verbose)
                        }
                      }
                      if (package == "glmmTMB") {
                        if (verbose) {
                          res.QE <- try(glmmTMB::glmmTMB(dat.grp ~ -1 + X.QE + (1 | study), offset = dat.off, family = dat.fam, start = list(theta = sqrt(glmmTMB::VarCorr(res.FE)[[1]][[1]][[1]])), verbose = verbose, data = NULL, control = do.call(glmmTMB::glmmTMBControl, glmerCtrl)), silent = !verbose)
                        }
                        else {
                          res.QE <- suppressMessages(try(glmmTMB::glmmTMB(dat.grp ~ -1 + X.QE + (1 | study), offset = dat.off, family = dat.fam, start = list(theta = sqrt(glmmTMB::VarCorr(res.FE)[[1]][[1]][[1]])), verbose = verbose, data = NULL, control = do.call(glmmTMB::glmmTMBControl, glmerCtrl)), silent = !verbose))
                        }
                      }
                    }
                    else {
                      res.QE <- res.FE
                    }
                    if (inherits(res.QE, "try-error")) {
                      warning(mstyle$warning(paste0("Cannot fit saturated model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))), call. = FALSE)
                    }
                    else {
                      QEconv <- TRUE
                      ll.QE <- c(logLik(res.QE))
                      if (package == "lme4") {
                        b2.QE <- cbind(lme4::fixef(res.QE)[-seq_len(p + 1)])
                        vb2.QE <- as.matrix(vcov(res.QE))[-seq_len(p + 1), -seq_len(p + 1), drop = FALSE]
                      }
                      if (package == "GLMMadaptive") {
                        b2.QE <- cbind(GLMMadaptive::fixef(res.QE)[-seq_len(p + 1)])
                        vb2.QE <- as.matrix(vcov(res.QE))[-seq_len(p + 1), -seq_len(p + 1), drop = FALSE]
                        vb2.QE <- vb2.QE[-nrow(vb2.QE), -ncol(vb2.QE)]
                      }
                      if (package == "glmmTMB") {
                        b2.QE <- cbind(glmmTMB::fixef(res.QE)$cond[-seq_len(p + 1)])
                        vb2.QE <- as.matrix(vcov(res.QE)$cond)[-seq_len(p + 1), -seq_len(p + 1), drop = FALSE]
                      }
                    }
                  }
                  if (method == "ML") {
                    if (verbose) 
                      message(mstyle$message("Fitting ML model ..."))
                    if (package == "lme4") {
                      if (verbose) {
                        if (cor) {
                          res.ML <- try(lme4::glmer(dat.grp ~ -1 + X.fit + const + (group | study), offset = dat.off, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = do.call(lme4::glmerControl, glmerCtrl)), silent = !verbose)
                        }
                        else {
                          res.ML <- try(lme4::glmer(dat.grp ~ -1 + X.fit + const + (group || study), offset = dat.off, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = do.call(lme4::glmerControl, glmerCtrl)), silent = !verbose)
                        }
                      }
                      else {
                        if (cor) {
                          res.ML <- suppressMessages(try(lme4::glmer(dat.grp ~ -1 + X.fit + const + (group | study), offset = dat.off, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = do.call(lme4::glmerControl, glmerCtrl)), silent = !verbose))
                        }
                        else {
                          res.ML <- suppressMessages(try(lme4::glmer(dat.grp ~ -1 + X.fit + const + (group || study), offset = dat.off, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = do.call(lme4::glmerControl, glmerCtrl)), silent = !verbose))
                        }
                      }
                    }
                    if (package == "GLMMadaptive") {
                      if (is.element(measure, c("OR", "RR", "RD"))) {
                        dat.mm <- data.frame(xi = dat.grp[, "xi"], mi = dat.grp[, "mi"], study = study, const = const, group = group)
                        if (cor) {
                          res.ML <- try(GLMMadaptive::mixed_model(cbind(xi, mi) ~ -1 + X.fit + const, random = ~group | study, data = dat.mm, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = glmerCtrl), silent = !verbose)
                        }
                        else {
                          res.ML <- try(GLMMadaptive::mixed_model(cbind(xi, mi) ~ -1 + X.fit + const, random = ~group || study, data = dat.mm, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = glmerCtrl), silent = !verbose)
                        }
                      }
                      else {
                        dat.mm <- data.frame(xi = dat.grp, study = study, const = const, group = group)
                        if (cor) {
                          res.ML <- try(GLMMadaptive::mixed_model(xi ~ -1 + X.fit + const + offset(dat.off), random = ~group | study, data = dat.mm, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = glmerCtrl), silent = !verbose)
                        }
                        else {
                          res.ML <- try(GLMMadaptive::mixed_model(xi ~ -1 + X.fit + const + offset(dat.off), random = ~group || study, data = dat.mm, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = glmerCtrl), silent = !verbose)
                        }
                      }
                    }
                    if (package == "glmmTMB") {
                      if (verbose) {
                        if (cor) {
                          res.ML <- try(glmmTMB::glmmTMB(dat.grp ~ -1 + X.fit + const + (group | study), offset = dat.off, family = dat.fam, verbose = verbose, data = NULL, control = do.call(glmmTMB::glmmTMBControl, glmerCtrl)), silent = !verbose)
                        }
                        else {
                          res.ML <- try(glmmTMB::glmmTMB(dat.grp ~ -1 + X.fit + const + (1 | study) + (group - 1 | study), offset = dat.off, family = dat.fam, verbose = verbose, data = NULL, control = do.call(glmmTMB::glmmTMBControl, glmerCtrl)), silent = !verbose)
                        }
                      }
                      else {
                        if (cor) {
                          res.ML <- suppressMessages(try(glmmTMB::glmmTMB(dat.grp ~ -1 + X.fit + const + (group | study), offset = dat.off, family = dat.fam, verbose = verbose, data = NULL, control = do.call(glmmTMB::glmmTMBControl, glmerCtrl)), silent = !verbose))
                        }
                        else {
                          res.ML <- suppressMessages(try(glmmTMB::glmmTMB(dat.grp ~ -1 + X.fit + const + (1 | study) + (group - 1 | study), offset = dat.off, family = dat.fam, verbose = verbose, data = NULL, control = do.call(glmmTMB::glmmTMBControl, glmerCtrl)), silent = !verbose))
                        }
                      }
                    }
                    if (inherits(res.ML, "try-error")) 
                      stop(mstyle$stop(paste0("Cannot fit ML model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))))
                    ll.ML <- c(logLik(res.ML))
                  }
                  if (is.element(method, c("FE", "EE", "CE"))) {
                    tau2 <- 0
                    if (package == "lme4") {
                      beta <- cbind(lme4::fixef(res.FE)[seq_len(p)])
                      vb <- as.matrix(vcov(res.FE))[seq_len(p), seq_len(p), drop = FALSE]
                      sigma2 <- lme4::VarCorr(res.FE)[[1]][1]
                    }
                    if (package == "GLMMadaptive") {
                      beta <- cbind(GLMMadaptive::fixef(res.FE)[seq_len(p)])
                      vb <- as.matrix(vcov(res.FE))[seq_len(p), seq_len(p), drop = FALSE]
                      sigma2 <- res.FE$D[1, 1]
                    }
                    if (package == "glmmTMB") {
                      beta <- cbind(glmmTMB::fixef(res.FE)$cond[seq_len(p)])
                      vb <- as.matrix(vcov(res.FE)$cond)[seq_len(p), seq_len(p), drop = FALSE]
                      sigma2 <- glmmTMB::VarCorr(res.FE)[[1]][[1]][[1]]
                    }
                    parms <- p + 1 + 1
                    p.eff <- p + 1
                    k.eff <- 2 * k
                  }
                  if (method == "ML") {
                    if (package == "lme4") {
                      beta <- cbind(lme4::fixef(res.ML)[seq_len(p)])
                      vb <- as.matrix(vcov(res.ML))[seq_len(p), seq_len(p), drop = FALSE]
                      if (cor) {
                        tau2 <- lme4::VarCorr(res.ML)[[1]][2, 2]
                        sigma2 <- lme4::VarCorr(res.ML)[[1]][1, 1]
                        rho <- lme4::VarCorr(res.ML)[[1]][1, 2]/sqrt(tau2 * sigma2)
                      }
                      else {
                        tau2 <- lme4::VarCorr(res.ML)[[2]][1]
                        sigma2 <- lme4::VarCorr(res.ML)[[1]][1]
                      }
                    }
                    if (package == "GLMMadaptive") {
                      beta <- cbind(GLMMadaptive::fixef(res.ML)[seq_len(p)])
                      vb <- as.matrix(vcov(res.ML))[seq_len(p), seq_len(p), drop = FALSE]
                      tau2 <- res.ML$D[2, 2]
                      sigma2 <- res.ML$D[1, 1]
                      if (cor) 
                        rho <- res.ML$D[1, 2]/sqrt(tau2 * sigma2)
                    }
                    if (package == "glmmTMB") {
                      beta <- cbind(glmmTMB::fixef(res.ML)$cond[seq_len(p)])
                      vb <- as.matrix(vcov(res.ML)$cond)[seq_len(p), seq_len(p), drop = FALSE]
                      if (cor) {
                        tau2 <- glmmTMB::VarCorr(res.ML)[[1]][[1]][2, 2]
                        sigma2 <- glmmTMB::VarCorr(res.ML)[[1]][[1]][1, 1]
                        rho <- glmmTMB::VarCorr(res.ML)[[1]][[1]][1, 2]/sqrt(tau2 * sigma2)
                      }
                      else {
                        tau2 <- glmmTMB::VarCorr(res.ML)[[1]][[2]][[1]]
                        sigma2 <- glmmTMB::VarCorr(res.ML)[[1]][[1]][[1]]
                      }
                    }
                    parms <- p + 1 + 2
                    p.eff <- p + 1
                    k.eff <- 2 * k
                  }
                }
            }
            if ((measure == "IRR" && model == "CM.EL") || (measure == "OR" && model == "CM.AL") || (measure == "OR" && model == "CM.EL")) {
                if (measure == "OR") {
                  dat.grp <- cbind(xi = ai, mi = ci)
                  dat.off <- log((ai + bi)/(ci + di))
                }
                if (measure == "IRR") {
                  dat.grp <- cbind(xi = x1i, mi = x2i)
                  dat.off <- log(t1i/t2i)
                }
                study <- factor(seq_len(k))
                X.fit <- X
                if (.isTRUE(ddd$retdat)) 
                  return(list(dat.grp = dat.grp, X.fit = X.fit, study = study, dat.off = if (!is.null(dat.off)) dat.off else NULL))
                if (verbose) 
                  message(mstyle$message("Fitting FE model ..."))
                res.FE <- try(glm(dat.grp ~ -1 + X.fit, offset = dat.off, family = binomial, control = glmCtrl), silent = !verbose)
                if (inherits(res.FE, "try-error")) 
                  stop(mstyle$stop(paste0("Cannot fit FE model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))))
                ll.FE <- c(logLik(res.FE))
                QEconv <- FALSE
                ll.QE <- NA
                if (!isTRUE(ddd$skiphet)) {
                  if (k > 1 && verbose) 
                    message(mstyle$message("Fitting saturated model ..."))
                  if (k > 1) {
                    X.QE <- model.matrix(~-1 + X.fit + study)
                    res.QE <- try(glm(dat.grp ~ -1 + X.QE, offset = dat.off, family = binomial, control = glmCtrl), silent = !verbose)
                  }
                  else {
                    res.QE <- res.FE
                  }
                  if (inherits(res.QE, "try-error")) {
                    warning(mstyle$warning(paste0("Cannot fit saturated model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))), call. = FALSE)
                  }
                  else {
                    QEconv <- TRUE
                    ll.QE <- c(logLik(res.QE))
                    b2.QE <- cbind(coef(res.QE, complete = FALSE)[-seq_len(p)])
                    vb2.QE <- vcov(res.QE, complete = FALSE)[-seq_len(p), -seq_len(p), drop = FALSE]
                  }
                }
                if (method == "ML") {
                  if (verbose) 
                    message(mstyle$message("Fitting ML model ..."))
                  if (package == "lme4") {
                    if (verbose) {
                      res.ML <- try(lme4::glmer(dat.grp ~ -1 + X.fit + (1 | study), offset = dat.off, family = binomial, nAGQ = nAGQ, verbose = verbose, control = do.call(lme4::glmerControl, glmerCtrl)), silent = !verbose)
                    }
                    else {
                      res.ML <- suppressMessages(try(lme4::glmer(dat.grp ~ -1 + X.fit + (1 | study), offset = dat.off, family = binomial, nAGQ = nAGQ, verbose = verbose, control = do.call(lme4::glmerControl, glmerCtrl)), silent = !verbose))
                    }
                  }
                  if (package == "GLMMadaptive") {
                    dat.mm <- data.frame(xi = dat.grp[, "xi"], mi = dat.grp[, "mi"], study = study)
                    res.ML <- try(GLMMadaptive::mixed_model(cbind(xi, mi) ~ -1 + X.fit + offset(dat.off), random = ~1 | study, data = dat.mm, family = binomial, nAGQ = nAGQ, verbose = verbose, control = glmerCtrl), silent = !verbose)
                  }
                  if (package == "glmmTMB") {
                    if (verbose) {
                      res.ML <- try(glmmTMB::glmmTMB(dat.grp ~ -1 + X.fit + (1 | study), offset = dat.off, family = binomial, verbose = verbose, data = NULL, control = do.call(glmmTMB::glmmTMBControl, glmerCtrl)), silent = !verbose)
                    }
                    else {
                      res.ML <- suppressMessages(try(glmmTMB::glmmTMB(dat.grp ~ -1 + X.fit + (1 | study), offset = dat.off, family = binomial, verbose = verbose, data = NULL, control = do.call(glmmTMB::glmmTMBControl, glmerCtrl)), silent = !verbose))
                    }
                  }
                  if (inherits(res.ML, "try-error")) 
                    stop(mstyle$stop(paste0("Cannot fit ML model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))))
                  if (package == "lme4") {
                    if (is.na(ll.QE)) {
                      ll.ML <- c(logLik(res.ML))
                    }
                    else {
                      if (verbose) {
                        ll.ML <- ll.QE - 1/2 * deviance(res.ML)
                      }
                      else {
                        ll.ML <- ll.QE - 1/2 * suppressWarnings(deviance(res.ML))
                      }
                    }
                  }
                  else {
                    ll.ML <- c(logLik(res.ML))
                  }
                }
                if (is.element(method, c("FE", "EE", "CE"))) {
                  beta <- cbind(coef(res.FE)[seq_len(p)])
                  vb <- vcov(res.FE)[seq_len(p), seq_len(p), drop = FALSE]
                  tau2 <- 0
                  sigma2 <- NA
                  parms <- p
                  p.eff <- p
                  k.eff <- k
                }
                if (method == "ML") {
                  if (package == "lme4") {
                    beta <- cbind(lme4::fixef(res.ML)[seq_len(p)])
                    vb <- as.matrix(vcov(res.ML))[seq_len(p), seq_len(p), drop = FALSE]
                    tau2 <- lme4::VarCorr(res.ML)[[1]][1]
                  }
                  if (package == "GLMMadaptive") {
                    beta <- cbind(GLMMadaptive::fixef(res.ML)[seq_len(p)])
                    vb <- as.matrix(vcov(res.ML))[seq_len(p), seq_len(p), drop = FALSE]
                    tau2 <- res.ML$D[1, 1]
                  }
                  if (package == "glmmTMB") {
                    beta <- cbind(glmmTMB::fixef(res.ML)$cond[seq_len(p)])
                    vb <- as.matrix(vcov(res.ML)$cond)[seq_len(p), seq_len(p), drop = FALSE]
                    tau2 <- glmmTMB::VarCorr(res.ML)[[1]][[1]][[1]]
                  }
                  sigma2 <- NA
                  parms <- p + 1
                  p.eff <- p
                  k.eff <- k
                }
            }
            if (measure == "OR" && model == "CM.EL") {
                if (verbose) 
                  message(mstyle$message("Fitting FE model ..."))
                if (is.element(optimizer, c("optim", "nlminb", "uobyqa", "newuoa", "bobyqa", "nloptr", "nlm", "hjk", "nmk", "mads", "ucminf", "lbfgsb3c", "subplex", "BBoptim", "optimParallel", "Rcgmin", "Rvmmin"))) {
                  if (optimizer == "optim") {
                    par.arg <- "par"
                    ctrl.arg <- ", control=optCtrl"
                  }
                  if (optimizer == "nlminb") {
                    par.arg <- "start"
                    ctrl.arg <- ", control=optCtrl"
                  }
                  if (is.element(optimizer, c("uobyqa", "newuoa", "bobyqa"))) {
                    par.arg <- "par"
                    optimizer <- paste0("minqa::", optimizer)
                    ctrl.arg <- ", control=optCtrl"
                  }
                  if (optimizer == "nloptr") {
                    par.arg <- "x0"
                    optimizer <- paste0("nloptr::nloptr")
                    ctrl.arg <- ", opts=optCtrl"
                  }
                  if (optimizer == "nlm") {
                    par.arg <- "p"
                    ctrl.arg <- paste(names(optCtrl), unlist(optCtrl), sep = "=", collapse = ", ")
                    if (nchar(ctrl.arg) != 0) 
                      ctrl.arg <- paste0(", ", ctrl.arg)
                  }
                  if (is.element(optimizer, c("hjk", "nmk", "mads"))) {
                    par.arg <- "par"
                    optimizer <- paste0("dfoptim::", optimizer)
                    ctrl.arg <- ", control=optCtrl"
                  }
                  if (is.element(optimizer, c("ucminf", "lbfgsb3c", "subplex"))) {
                    par.arg <- "par"
                    optimizer <- paste0(optimizer, "::", optimizer)
                    ctrl.arg <- ", control=optCtrl"
                  }
                  if (optimizer == "BBoptim") {
                    par.arg <- "par"
                    optimizer <- "BB::BBoptim"
                    ctrl.arg <- ", quiet=TRUE, control=optCtrl"
                  }
                  if (optimizer == "Rcgmin") {
                    par.arg <- "par"
                    optimizer <- "Rcgmin::Rcgmin"
                    ctrl.arg <- ", control=optCtrl"
                  }
                  if (optimizer == "Rvmmin") {
                    par.arg <- "par"
                    optimizer <- "Rvmmin::Rvmmin"
                    ctrl.arg <- ", control=optCtrl"
                  }
                  if (optimizer == "optimParallel") {
                    par.arg <- "par"
                    optimizer <- paste0("optimParallel::optimParallel")
                    ctrl.arg <- ", control=optCtrl, parallel=parallel"
                    parallel$cl <- NULL
                    if (is.null(cl)) {
                      ncpus <- as.integer(ncpus)
                      if (ncpus < 1) 
                        stop(mstyle$stop("Control argument 'ncpus' must be >= 1."))
                      cl <- parallel::makePSOCKcluster(ncpus)
                      on.exit(parallel::stopCluster(cl), add = TRUE)
                    }
                    else {
                      if (!inherits(cl, "SOCKcluster")) 
                        stop(mstyle$stop("Specified cluster is not of class 'SOCKcluster'."))
                    }
                    parallel$cl <- cl
                    if (is.null(parallel$forward)) 
                      parallel$forward <- FALSE
                    if (is.null(parallel$loginfo)) {
                      if (verbose) {
                        parallel$loginfo <- TRUE
                      }
                      else {
                        parallel$loginfo <- FALSE
                      }
                    }
                  }
                  optcall <- paste(optimizer, "(", par.arg, "=c(coef(res.FE)[seq_len(p)], 0),\n               .dnchg, ", ifelse(optimizer == "optim", "method=optmethod, ", ""), "ai=ai, bi=bi, ci=ci, di=di, X.fit=X.fit, random=FALSE,\n               verbose=verbose, digits=digits,\n               dnchgcalc=con$dnchgcalc, dnchgprec=con$dnchgprec, intCtrl=intCtrl", ctrl.arg, ")\n", sep = "")
                  if (verbose) {
                    res.FE <- try(eval(str2lang(optcall)), silent = !verbose)
                  }
                  else {
                    res.FE <- try(suppressWarnings(eval(str2lang(optcall))), silent = !verbose)
                  }
                  if (optimizer == "optimParallel::optimParallel" && verbose) {
                    tmp <- capture.output(print(res.FE$loginfo))
                    .print.output(tmp, mstyle$verbose)
                  }
                  if (inherits(res.FE, "try-error")) 
                    stop(mstyle$stop(paste0("Cannot fit FE model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))))
                  if (is.element(optimizer, c("optim", "nlminb", "dfoptim::hjk", "dfoptim::nmk", "lbfgsb3c::lbfgsb3c", "subplex::subplex", "BB::BBoptim", "Rcgmin::Rcgmin", "Rvmmin:Rvmmin", "optimParallel::optimParallel")) && res.FE$convergence != 0) 
                    stop(mstyle$stop(paste0("Cannot fit FE model. Optimizer (", optimizer, ") did not achieve convergence (convergence = ", res.FE$convergence, ").")))
                  if (is.element(optimizer, c("dfoptim::mads")) && res.FE$convergence > optCtrl$tol) 
                    stop(mstyle$stop(paste0("Cannot fit FE model. Optimizer (", optimizer, ") did not achieve convergence (convergence = ", res.FE$convergence, ").")))
                  if (is.element(optimizer, c("minqa::uobyqa", "minqa::newuoa", "minqa::bobyqa")) && res.FE$ierr != 0) 
                    stop(mstyle$stop(paste0("Cannot fit FE model. Optimizer (", optimizer, ") did not achieve convergence (ierr = ", res.FE$ierr, ").")))
                  if (optimizer == "nloptr::nloptr" && !(res.FE$status >= 1 && res.FE$status <= 4)) 
                    stop(mstyle$stop(paste0("Cannot fit FE model. Optimizer (", optimizer, ") did not achieve convergence (status = ", res.FE$status, ").")))
                  if (optimizer == "ucminf::ucminf" && !(res.FE$convergence == 1 || res.FE$convergence == 2)) 
                    stop(mstyle$stop(paste0("Cannot fit FE model. Optimizer (", optimizer, ") did not achieve convergence (convergence = ", res.FE$convergence, ").")))
                  if (verbose > 2) {
                    cat("\n")
                    tmp <- capture.output(print(res.FE))
                    .print.output(tmp, mstyle$verbose)
                  }
                  if (optimizer == "nloptr::nloptr") 
                    res.FE$par <- res.FE$solution
                  if (optimizer == "nlm") 
                    res.FE$par <- res.FE$estimate
                  if (verbose > 1) 
                    message(mstyle$message("Computing Hessian ..."))
                  if (con$hesspack == "numDeriv") 
                    h.FE <- numDeriv::hessian(.dnchg, x = res.FE$par, method.args = hessianCtrl, ai = ai, bi = bi, ci = ci, di = di, X.fit = X.fit, random = FALSE, verbose = verbose, digits = digits, dnchgcalc = con$dnchgcalc, dnchgprec = con$dnchgprec)
                  if (con$hesspack == "pracma") 
                    h.FE <- pracma::hessian(.dnchg, x0 = res.FE$par, ai = ai, bi = bi, ci = ci, di = di, X.fit = X.fit, random = FALSE, verbose = verbose, digits = digits, dnchgcalc = con$dnchgcalc, dnchgprec = con$dnchgprec)
                  if (is.element(optimizer, c("optim", "dfoptim::hjk", "dfoptim::nmk", "dfoptim::mads", "ucminf::ucminf", "lbfgsb3c::lbfgsb3c", "subplex::subplex", "BB::BBoptim", "Rcgmin::Rcgmin", "Rvmmin:Rvmmin", "optimParallel::optimParallel"))) 
                    ll.FE <- -1 * res.FE$value
                  if (is.element(optimizer, c("nlminb", "nloptr::nloptr"))) 
                    ll.FE <- -1 * res.FE$objective
                  if (is.element(optimizer, c("minqa::uobyqa", "minqa::newuoa", "minqa::bobyqa"))) 
                    ll.FE <- -1 * res.FE$fval
                  if (optimizer == "nlm") 
                    ll.FE <- -1 * res.FE$minimum
                  if (QEconv) {
                    if (k > 1 && verbose) 
                      message(mstyle$message("Fitting saturated model ..."))
                    if (k > 1) {
                      b.QE <- coef(res.QE, complete = TRUE)
                      is.aliased <- is.na(b.QE)
                      b.QE <- b.QE[!is.aliased]
                      X.QE <- X.QE[, !is.aliased, drop = FALSE]
                      optcall <- paste(optimizer, "(", par.arg, "=c(b.QE, 0),\n                     .dnchg, ", ifelse(optimizer == "optim", "method=optmethod, ", ""), "ai=ai, bi=bi, ci=ci, di=di, X.fit=X.QE, random=FALSE,\n                     verbose=verbose, digits=digits,\n                     dnchgcalc=con$dnchgcalc, dnchgprec=con$dnchgprec, intCtrl=intCtrl", ctrl.arg, ")\n", sep = "")
                      if (verbose) {
                        res.QE <- try(eval(str2lang(optcall)), silent = !verbose)
                      }
                      else {
                        res.QE <- try(suppressWarnings(eval(str2lang(optcall))), silent = !verbose)
                      }
                      if (optimizer == "optimParallel::optimParallel" && verbose) {
                        tmp <- capture.output(print(res.QE$loginfo))
                        .print.output(tmp, mstyle$verbose)
                      }
                      if (inherits(res.QE, "try-error")) {
                        warning(mstyle$warning(paste0("Cannot fit saturated model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))), call. = FALSE)
                        QEconv <- FALSE
                        ll.QE <- NA
                      }
                      if (QEconv && is.element(optimizer, c("optim", "nlminb", "dfoptim::hjk", "dfoptim::nmk", "lbfgsb3c::lbfgsb3c", "subplex::subplex", "BB::BBoptim", "Rcgmin::Rcgmin", "Rvmmin:Rvmmin", "optimParallel::optimParallel")) && res.QE$convergence != 0) {
                        warning(mstyle$warning(paste0("Cannot fit saturated model. Optimizer (", optimizer, ") did not achieve convergence (convergence = ", res.QE$convergence, ").")), call. = FALSE)
                        QEconv <- FALSE
                        ll.QE <- NA
                      }
                      if (QEconv && is.element(optimizer, c("dfoptim::mads")) && res.QE$convergence > optCtrl$tol) {
                        warning(mstyle$warning(paste0("Cannot fit saturated model. Optimizer (", optimizer, ") did not achieve convergence (convergence = ", res.QE$convergence, ").")), call. = FALSE)
                        QEconv <- FALSE
                        ll.QE <- NA
                      }
                      if (QEconv && is.element(optimizer, c("minqa::uobyqa", "minqa::newuoa", "minqa::bobyqa")) && res.QE$ierr != 0) {
                        warning(mstyle$warning(paste0("Cannot fit saturated model. Optimizer (", optimizer, ") did not achieve convergence (ierr = ", res.QE$ierr, ").")), call. = FALSE)
                        QEconv <- FALSE
                        ll.QE <- NA
                      }
                      if (QEconv && optimizer == "nloptr::nloptr" && !(res.QE$status >= 1 && res.QE$status <= 4)) {
                        warning(mstyle$warning(paste0("Cannot fit saturated model. Optimizer (", optimizer, ") did not achieve convergence (status = ", res.QE$status, ").")), call. = FALSE)
                        QEconv <- FALSE
                        ll.QE <- NA
                      }
                      if (QEconv && optimizer == "ucminf::ucminf" && !(res.QE$convergence == 1 || res.QE$convergence == 2)) {
                        warning(mstyle$warning(paste0("Cannot fit saturated model. Optimizer (", optimizer, ") did not achieve convergence (convergence = ", res.QE$convergence, ").")), call. = FALSE)
                        QEconv <- FALSE
                        ll.QE <- NA
                      }
                      if (verbose > 2) {
                        cat("\n")
                        tmp <- capture.output(print(res.QE))
                        .print.output(tmp, mstyle$verbose)
                      }
                      if (QEconv && optimizer == "nloptr::nloptr") 
                        res.QE$par <- res.QE$solution
                      if (QEconv && optimizer == "nlm") 
                        res.QE$par <- res.QE$estimate
                      if (QEconv) {
                        if (verbose > 1) 
                          message(mstyle$message("Computing Hessian ..."))
                        if (con$hesspack == "numDeriv") 
                          h.QE <- numDeriv::hessian(.dnchg, x = res.QE$par, method.args = hessianCtrl, ai = ai, bi = bi, ci = ci, di = di, X.fit = X.QE, random = FALSE, verbose = verbose, digits = digits, dnchgcalc = con$dnchgcalc, dnchgprec = con$dnchgprec)
                        if (con$hesspack == "pracma") 
                          h.QE <- pracma::hessian(.dnchg, x0 = res.QE$par, ai = ai, bi = bi, ci = ci, di = di, X.fit = X.QE, random = FALSE, verbose = verbose, digits = digits, dnchgcalc = con$dnchgcalc, dnchgprec = con$dnchgprec)
                      }
                    }
                    else {
                      res.QE <- res.FE
                      h.QE <- h.FE
                    }
                  }
                  if (k > 1 && QEconv) {
                    if (is.element(optimizer, c("optim", "dfoptim::hjk", "dfoptim::nmk", "dfoptim::mads", "ucminf::ucminf", "lbfgsb3c::lbfgsb3c", "subplex::subplex", "BB::BBoptim", "Rcgmin::Rcgmin", "Rvmmin:Rvmmin", "optimParallel::optimParallel"))) 
                      ll.QE <- -1 * res.QE$value
                    if (is.element(optimizer, c("nlminb", "nloptr::nloptr"))) 
                      ll.QE <- -1 * res.QE$objective
                    if (is.element(optimizer, c("minqa::uobyqa", "minqa::newuoa", "minqa::bobyqa"))) 
                      ll.QE <- -1 * res.QE$fval
                    if (optimizer == "nlm") 
                      ll.QE <- -1 * res.QE$minimum
                    b2.QE <- res.QE$par
                    hessian <- h.QE
                    p.QE <- length(b2.QE)
                    b2.QE <- b2.QE[-p.QE]
                    hessian <- hessian[-p.QE, -p.QE, drop = FALSE]
                    p.QE <- length(b2.QE)
                    is.0 <- colSums(hessian == 0) == p.QE
                    b2.QE <- b2.QE[!is.0]
                    hessian <- hessian[!is.0, !is.0, drop = FALSE]
                    b2.QE <- cbind(b2.QE[-seq_len(p)])
                    h.A <- hessian[seq_len(p), seq_len(p), drop = FALSE]
                    h.B <- hessian[seq_len(p), -seq_len(p), drop = FALSE]
                    h.C <- hessian[-seq_len(p), seq_len(p), drop = FALSE]
                    h.D <- hessian[-seq_len(p), -seq_len(p), drop = FALSE]
                    chol.h.A <- try(chol(h.A), silent = !verbose)
                    if (inherits(chol.h.A, "try-error") || anyNA(chol.h.A)) {
                      warning(mstyle$warning("Cannot invert Hessian for saturated model."), call. = FALSE)
                      QE.Wld <- NA
                    }
                    else {
                      Ivb2.QE <- h.D - h.C %*% chol2inv(chol.h.A) %*% h.B
                      QE.Wld <- c(t(b2.QE) %*% Ivb2.QE %*% b2.QE)
                    }
                  }
                }
                if (is.element(optimizer, c("clogit", "clogistic"))) {
                  event <- unlist(lapply(seq_len(k), function(i) c(rep.int(1, ai[i]), rep.int(0, bi[i]), rep.int(1, ci[i]), rep.int(0, di[i]))))
                  group1 <- unlist(lapply(seq_len(k), function(i) c(rep.int(1, ai[i]), rep.int(1, bi[i]), rep.int(0, ci[i]), rep.int(0, di[i]))))
                  study.l <- factor(rep(seq_len(k), times = ni))
                  X.fit.l <- X[rep(seq_len(k), times = ni), , drop = FALSE]
                  X.fit.l <- cbind(group1 * X.fit.l)
                  const <- rep(1, length(event))
                  if (.isTRUE(ddd$retdat)) 
                    return(data.frame(event, group1, study.l, X.fit.l, const))
                  if (k > 1) {
                    if (optimizer == "clogit") {
                      args.clogit <- clogitCtrl
                      args.clogit$formula <- event ~ X.fit.l + strata(study.l)
                      res.FE <- try(do.call(clogit, args.clogit), silent = !verbose)
                    }
                    if (optimizer == "clogistic") {
                      args.clogistic <- clogisticCtrl
                      args.clogistic$formula <- event ~ X.fit.l
                      args.clogistic$strata <- study.l
                      res.FE <- try(do.call(Epi::clogistic, args.clogistic), silent = !verbose)
                    }
                  }
                  else {
                    stop(mstyle$stop(paste0("Cannot use '", optimizer, "' optimizer when k=1.")))
                  }
                  if (inherits(res.FE, "try-error")) 
                    stop(mstyle$stop(paste0("Cannot fit FE model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))))
                  if (QEconv) {
                    if (verbose) 
                      message(mstyle$message("Fitting saturated model ..."))
                    b.QE <- coef(res.QE, complete = TRUE)
                    is.aliased <- is.na(b.QE)
                    X.QE.l <- model.matrix(~-1 + X.fit.l + study.l:group1)
                    X.QE.l <- X.QE.l[, !is.aliased, drop = FALSE]
                    X.QE <- X.QE[, !is.aliased, drop = FALSE]
                    if (optimizer == "clogit") {
                      args.clogit <- clogitCtrl
                      args.clogit$formula <- event ~ X.QE.l + strata(study.l)
                      if (verbose) {
                        res.QE <- try(do.call(clogit, args.clogit), silent = !verbose)
                      }
                      else {
                        res.QE <- try(suppressWarnings(do.call(clogit, args.clogit)), silent = !verbose)
                      }
                    }
                    if (optimizer == "clogistic") {
                      args.clogistic <- clogisticCtrl
                      args.clogistic$formula <- event ~ X.QE.l
                      args.clogistic$strata <- study.l
                      res.QE <- try(do.call(Epi::clogistic, args.clogistic), silent = !verbose)
                    }
                    if (inherits(res.QE, "try-error")) 
                      stop(mstyle$stop(paste0("Cannot fit saturated model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))))
                    ll.FE <- -1 * .dnchg(c(cbind(coef(res.FE)), 0), ai = ai, bi = bi, ci = ci, di = di, X.fit = X.fit, random = FALSE, verbose = verbose, digits = digits, dnchgcalc = con$dnchgcalc, dnchgprec = con$dnchgprec)
                    ll.QE <- -1 * .dnchg(c(cbind(coef(res.QE)), 0), ai = ai, bi = bi, ci = ci, di = di, X.fit = X.QE, random = FALSE, verbose = verbose, digits = digits, dnchgcalc = con$dnchgcalc, dnchgprec = con$dnchgprec)
                    b2.QE <- cbind(coef(res.QE)[-seq_len(p)])
                    vb2.QE <- vcov(res.QE)[-seq_len(p), -seq_len(p), drop = FALSE]
                  }
                }
                if (method == "ML") {
                  if (verbose) 
                    message(mstyle$message("Fitting ML model ..."))
                  optcall <- paste(optimizer, "(", par.arg, "=c(beta, log(tau2+.01)),\n               .dnchg, ", ifelse(optimizer == "optim", "method=optmethod, ", ""), "ai=ai, bi=bi, ci=ci, di=di, X.fit=X.fit, random=TRUE,\n               verbose=verbose, digits=digits,\n               dnchgcalc=con$dnchgcalc, dnchgprec=con$dnchgprec, intCtrl=intCtrl", ctrl.arg, ")\n", sep = "")
                  if (verbose) {
                    res.ML <- try(eval(str2lang(optcall)), silent = !verbose)
                  }
                  else {
                    res.ML <- try(suppressWarnings(eval(str2lang(optcall))), silent = !verbose)
                  }
                  if (optimizer == "optimParallel::optimParallel" && verbose) {
                    tmp <- capture.output(print(res.ML$loginfo))
                    .print.output(tmp, mstyle$verbose)
                  }
                  if (inherits(res.ML, "try-error")) 
                    stop(mstyle$stop(paste0("Cannot fit ML model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))))
                  if (is.element(optimizer, c("optim", "nlminb", "dfoptim::hjk", "dfoptim::nmk", "lbfgsb3c::lbfgsb3c", "subplex::subplex", "BB::BBoptim", "Rcgmin::Rcgmin", "Rvmmin:Rvmmin", "optimParallel::optimParallel")) && res.ML$convergence != 0) 
                    stop(mstyle$stop(paste0("Cannot fit ML model. Optimizer (", optimizer, ") did not achieve convergence (convergence = ", res.ML$convergence, ").")))
                  if (is.element(optimizer, c("dfoptim::mads")) && res.ML$convergence > optCtrl$tol) 
                    stop(mstyle$stop(paste0("Cannot fit ML model. Optimizer (", optimizer, ") did not achieve convergence (convergence = ", res.ML$convergence, ").")))
                  if (is.element(optimizer, c("minqa::uobyqa", "minqa::newuoa", "minqa::bobyqa")) && res.ML$ierr != 0) 
                    stop(mstyle$stop(paste0("Cannot fit ML model. Optimizer (", optimizer, ") did not achieve convergence (ierr = ", res.ML$ierr, ").")))
                  if (optimizer == "nloptr::nloptr" && !(res.ML$status >= 1 && res.ML$status <= 4)) 
                    stop(mstyle$stop(paste0("Cannot fit ML model. Optimizer (", optimizer, ") did not achieve convergence (status = ", res.ML$status, ").")))
                  if (optimizer == "ucminf::ucminf" && !(res.ML$convergence == 1 || res.ML$convergence == 2)) 
                    stop(mstyle$stop(paste0("Cannot fit ML model. Optimizer (", optimizer, ") did not achieve convergence (convergence = ", res.ML$convergence, ").")))
                  if (verbose > 2) {
                    cat("\n")
                    tmp <- capture.output(print(res.ML))
                    .print.output(tmp, mstyle$verbose)
                  }
                  if (optimizer == "nloptr::nloptr") 
                    res.ML$par <- res.ML$solution
                  if (optimizer == "nlm") 
                    res.ML$par <- res.ML$estimate
                  if (verbose > 1) 
                    message(mstyle$message("Computing Hessian ..."))
                  tau2eff0 <- exp(res.ML$par[p + 1]) < con$tau2tol
                  if (tau2eff0) 
                    method <- "T0"
                  if (con$hesspack == "numDeriv") 
                    h.ML <- numDeriv::hessian(.dnchg, x = res.ML$par, method.args = hessianCtrl, ai = ai, bi = bi, ci = ci, di = di, X.fit = X.fit, random = !tau2eff0, verbose = verbose, digits = digits, dnchgcalc = con$dnchgcalc, dnchgprec = con$dnchgprec, intCtrl = intCtrl)
                  if (con$hesspack == "pracma") 
                    h.ML <- pracma::hessian(.dnchg, x0 = res.ML$par, ai = ai, bi = bi, ci = ci, di = di, X.fit = X.fit, random = !tau2eff0, verbose = verbose, digits = digits, dnchgcalc = con$dnchgcalc, dnchgprec = con$dnchgprec, intCtrl = intCtrl)
                  if (is.element(optimizer, c("optim", "dfoptim::hjk", "dfoptim::nmk", "dfoptim::mads", "ucminf::ucminf", "lbfgsb3c::lbfgsb3c", "subplex::subplex", "BB::BBoptim", "Rcgmin::Rcgmin", "Rvmmin:Rvmmin", "optimParallel::optimParallel"))) 
                    ll.ML <- -1 * res.ML$value
                  if (is.element(optimizer, c("nlminb", "nloptr::nloptr"))) 
                    ll.ML <- -1 * res.ML$objective
                  if (is.element(optimizer, c("minqa::uobyqa", "minqa::newuoa", "minqa::bobyqa"))) 
                    ll.ML <- -1 * res.ML$fval
                  if (optimizer == "nlm") 
                    ll.ML <- -1 * res.ML$minimum
                }
                if (is.element(method, c("FE", "EE", "CE", "T0"))) {
                  if (!is.element(optimizer, c("clogit", "clogistic"))) {
                    beta <- cbind(res.FE$par[seq_len(p)])
                    chol.h <- try(chol(h.FE[seq_len(p), seq_len(p)]), silent = !verbose)
                    if (inherits(chol.h, "try-error") || anyNA(chol.h)) {
                      if (anyNA(chol.h)) 
                        stop(mstyle$stop(paste0("Cannot invert Hessian for the ", ifelse(method == "T0", "ML", method), " model.")))
                      warning(mstyle$warning("Choleski factorization of Hessian failed. Trying inversion via QR decomposition."), call. = FALSE)
                      vb <- try(qr.solve(h.FE[seq_len(p), seq_len(p)]), silent = !verbose)
                      if (inherits(vb, "try-error")) 
                        stop(mstyle$stop(paste0("Cannot invert Hessian for the ", ifelse(method == "T0", "ML", method), " model.")))
                    }
                    else {
                      vb <- chol2inv(chol.h)
                    }
                  }
                  if (is.element(optimizer, c("clogit", "clogistic"))) {
                    beta <- cbind(coef(res.FE)[seq_len(p)])
                    vb <- vcov(res.FE)[seq_len(p), seq_len(p), drop = FALSE]
                  }
                  tau2 <- 0
                  sigma2 <- NA
                  parms <- p
                  p.eff <- p
                  k.eff <- k
                }
                if (method == "ML") {
                  beta <- cbind(res.ML$par[seq_len(p)])
                  chol.h <- try(chol(h.ML), silent = !verbose)
                  if (inherits(chol.h, "try-error") || anyNA(chol.h)) {
                    if (anyNA(chol.h)) 
                      stop(mstyle$stop("Cannot invert Hessian for the ML model."))
                    warning(mstyle$warning("Choleski factorization of Hessian failed. Trying inversion via QR decomposition."), call. = FALSE)
                    vb.f <- try(qr.solve(h.ML), silent = !verbose)
                    if (inherits(vb.f, "try-error")) 
                      stop(mstyle$stop("Cannot invert Hessian for the ML model."))
                  }
                  else {
                    vb.f <- chol2inv(chol.h)
                  }
                  vb <- vb.f[seq_len(p), seq_len(p), drop = FALSE]
                  if (any(diag(vb) <= 0)) 
                    stop(mstyle$stop("Cannot compute var-cov matrix of the fixed effects."))
                  tau2 <- exp(res.ML$par[p + 1])
                  sigma2 <- NA
                  parms <- p + 1
                  p.eff <- p
                  k.eff <- k
                  if (vb.f[p + 1, p + 1] >= 0) {
                    se.tau2 <- sqrt(vb.f[p + 1, p + 1]) * tau2
                    crit <- qnorm(level/2, lower.tail = FALSE)
                    ci.lb.tau2 <- exp(res.ML$par[p + 1] - crit * sqrt(vb.f[p + 1, p + 1]))
                    ci.ub.tau2 <- exp(res.ML$par[p + 1] + crit * sqrt(vb.f[p + 1, p + 1]))
                  }
                }
                if (is.element(method, c("ML", "T0"))) {
                  tmp <- try(rma.uni(measure = "PETO", ai = ai, bi = bi, ci = ci, di = di, add = 0, mods = X.fit, intercept = FALSE, skipr2 = TRUE), silent = TRUE)
                  if (!inherits(tmp, "try-error")) {
                    gvar1 <- det(vcov(tmp))
                    gvar2 <- det(vb)
                    ratio <- (gvar1/gvar2)^(1/(2 * m))
                    if (!is.na(ratio) && ratio >= 100) {
                      warning(mstyle$warning("Standard errors of fixed effects appear to be unusually small. Treat results with caution."), call. = FALSE)
                      se.warn <- TRUE
                    }
                    if (!is.na(ratio) && ratio <= 1/100) {
                      warning(mstyle$warning("Standard errors of fixed effects appear to be unusually large. Treat results with caution."), call. = FALSE)
                      se.warn <- TRUE
                    }
                  }
                }
                if (method == "T0") {
                  tau2 <- exp(res.ML$par[p + 1])
                  parms <- p + 1
                  se.tau2 <- 0
                  method <- "ML"
                }
            }
        }
        if (is.element(measure, c("PLO", "PR", "PLN", "IRLN"))) {
            if (is.element(measure, c("PLO", "PR", "PLN"))) {
                dat.grp <- cbind(xi = xi, mi = mi)
                if (is.null(ddd$family)) {
                  if (measure == "PLO") 
                    dat.fam <- binomial(link = link)
                  if (measure == "PR") 
                    dat.fam <- binomial(link = link)
                  if (measure == "PLN") 
                    dat.fam <- binomial(link = link)
                }
                else {
                  dat.fam <- ddd$family
                }
                dat.off <- NULL
            }
            if (is.element(measure, c("IRLN"))) {
                dat.grp <- xi
                if (is.null(ddd$family)) {
                  dat.fam <- poisson(link = link)
                }
                else {
                  dat.fam <- ddd$family
                }
                dat.off <- log(ti)
            }
            study <- factor(seq_len(k))
            X.fit <- X
            if (.isTRUE(ddd$retdat)) 
                return(list(dat.grp = dat.grp, X.fit = X.fit, study = study, dat.off = if (!is.null(dat.off)) dat.off else NULL, dat.fam = dat.fam))
            if (verbose) 
                message(mstyle$message("Fitting FE model ..."))
            res.FE <- try(glm(dat.grp ~ -1 + X.fit, offset = dat.off, family = dat.fam, control = glmCtrl), silent = !verbose)
            if (inherits(res.FE, "try-error")) 
                stop(mstyle$stop(paste0("Cannot fit FE model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))))
            ll.FE <- c(logLik(res.FE))
            QEconv <- FALSE
            ll.QE <- NA
            if (!isTRUE(ddd$skiphet)) {
                if (k > 1 && verbose) 
                  message(mstyle$message("Fitting saturated model ..."))
                if (k > 1) {
                  X.QE <- model.matrix(~-1 + X.fit + study)
                  if (verbose) {
                    res.QE <- try(glm(dat.grp ~ -1 + X.QE, offset = dat.off, family = dat.fam, control = glmCtrl), silent = !verbose)
                  }
                  else {
                    res.QE <- try(suppressWarnings(glm(dat.grp ~ -1 + X.QE, offset = dat.off, family = dat.fam, control = glmCtrl)), silent = !verbose)
                  }
                }
                else {
                  res.QE <- res.FE
                }
                if (inherits(res.QE, "try-error")) {
                  warning(mstyle$warning(paste0("Cannot fit saturated model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))), call. = FALSE)
                }
                else {
                  QEconv <- TRUE
                  ll.QE <- c(logLik(res.QE))
                  b2.QE <- cbind(coef(res.QE, complete = FALSE)[-seq_len(p)])
                  vb2.QE <- vcov(res.QE, complete = FALSE)[-seq_len(p), -seq_len(p), drop = FALSE]
                }
            }
            if (method == "ML") {
                if (verbose) 
                  message(mstyle$message("Fitting ML model ..."))
                if (package == "lme4") {
                  if (verbose) {
                    res.ML <- try(lme4::glmer(dat.grp ~ -1 + X.fit + (1 | study), offset = dat.off, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = do.call(lme4::glmerControl, glmerCtrl)), silent = !verbose)
                  }
                  else {
                    res.ML <- suppressMessages(try(lme4::glmer(dat.grp ~ -1 + X.fit + (1 | study), offset = dat.off, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = do.call(lme4::glmerControl, glmerCtrl)), silent = !verbose))
                  }
                }
                if (package == "GLMMadaptive") {
                  if (is.element(measure, c("PLO", "PR", "PLN"))) {
                    dat.mm <- data.frame(xi = dat.grp[, "xi"], mi = dat.grp[, "mi"], study = study)
                    res.ML <- try(GLMMadaptive::mixed_model(cbind(xi, mi) ~ -1 + X.fit, random = ~1 | study, data = dat.mm, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = glmerCtrl), silent = !verbose)
                  }
                  else {
                    dat.mm <- data.frame(xi = dat.grp, study = study)
                    res.ML <- try(GLMMadaptive::mixed_model(xi ~ -1 + X.fit + offset(dat.off), random = ~1 | study, data = dat.mm, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = glmerCtrl), silent = !verbose)
                  }
                }
                if (package == "glmmTMB") {
                  if (verbose) {
                    res.ML <- try(glmmTMB::glmmTMB(dat.grp ~ -1 + X.fit + (1 | study), offset = dat.off, family = dat.fam, verbose = verbose, data = NULL, control = do.call(glmmTMB::glmmTMBControl, glmerCtrl)), silent = !verbose)
                  }
                  else {
                    res.ML <- suppressMessages(try(glmmTMB::glmmTMB(dat.grp ~ -1 + X.fit + (1 | study), offset = dat.off, family = dat.fam, verbose = verbose, data = NULL, control = do.call(glmmTMB::glmmTMBControl, glmerCtrl)), silent = !verbose))
                  }
                }
                if (inherits(res.ML, "try-error")) 
                  stop(mstyle$stop(paste0("Cannot fit ML model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))))
                if (package == "lme4") {
                  ll.ML <- ll.QE - 1/2 * deviance(res.ML)
                }
                else {
                  ll.ML <- c(logLik(res.ML))
                }
            }
            if (is.element(method, c("FE", "EE", "CE"))) {
                beta <- cbind(coef(res.FE)[seq_len(p)])
                vb <- vcov(res.FE)[seq_len(p), seq_len(p), drop = FALSE]
                tau2 <- 0
                sigma2 <- NA
                parms <- p
                p.eff <- p
                k.eff <- k
            }
            if (method == "ML") {
                if (package == "lme4") {
                  beta <- cbind(lme4::fixef(res.ML)[seq_len(p)])
                  vb <- as.matrix(vcov(res.ML))[seq_len(p), seq_len(p), drop = FALSE]
                  tau2 <- lme4::VarCorr(res.ML)[[1]][1]
                }
                if (package == "GLMMadaptive") {
                  beta <- cbind(GLMMadaptive::fixef(res.ML)[seq_len(p)])
                  vb <- as.matrix(vcov(res.ML))[seq_len(p), seq_len(p), drop = FALSE]
                  tau2 <- res.ML$D[1, 1]
                }
                if (package == "glmmTMB") {
                  beta <- cbind(glmmTMB::fixef(res.ML)$cond[seq_len(p)])
                  vb <- as.matrix(vcov(res.ML)$cond)[seq_len(p), seq_len(p), drop = FALSE]
                  tau2 <- glmmTMB::VarCorr(res.ML)[[1]][[1]][[1]]
                }
                sigma2 <- NA
                parms <- p + 1
                p.eff <- p
                k.eff <- k
            }
        }
        if (verbose > 1) 
            message(mstyle$message("Conducting heterogeneity tests ..."))
        if (k > 1 && QEconv) {
            if (!(measure == "OR" && model == "CM.EL" && !is.element(optimizer, c("clogit", "clogistic")))) {
                if (nrow(vb2.QE) > 0) {
                  chol.h <- try(chol(vb2.QE), silent = !verbose)
                  if (inherits(chol.h, "try-error") || anyNA(chol.h)) {
                    warning(mstyle$warning("Cannot invert Hessian for saturated model."), call. = FALSE)
                    QE.Wld <- NA
                  }
                  else {
                    QE.Wld <- try(c(t(b2.QE) %*% chol2inv(chol.h) %*% b2.QE), silent = !verbose)
                    if (inherits(QE.Wld, "try-error")) {
                      warning(mstyle$warning("Cannot invert Hessian for saturated model."), call. = FALSE)
                      QE.Wld <- NA
                    }
                  }
                }
                else {
                  QE.Wld <- 0
                }
            }
            QE.LRT <- -2 * (ll.FE - ll.QE)
            QE.Wld[QE.Wld <= 0] <- 0
            QE.LRT[QE.LRT <= 0] <- 0
            QE.df <- k - p
            if (QE.df > 0) {
                QEp.Wld <- pchisq(QE.Wld, df = QE.df, lower.tail = FALSE)
                QEp.LRT <- pchisq(QE.LRT, df = QE.df, lower.tail = FALSE)
            }
            else {
                QEp.Wld <- 1
                QEp.LRT <- 1
            }
        }
        else {
            QE.Wld <- NA
            QE.LRT <- NA
            QEp.Wld <- NA
            QEp.LRT <- NA
            QE.df <- NA
        }
        wi <- 1/vi
        W <- diag(wi, nrow = k.yi, ncol = k.yi)
        stXWX <- .invcalc(X = X.yi, W = W, k = k.yi)
        P <- W - W %*% X.yi %*% stXWX %*% crossprod(X.yi, W)
        if (i2def == "1") 
            vt <- (k.yi - p)/.tr(P)
        if (i2def == "2") 
            vt <- 1/mean(wi)
        I2 <- 100 * tau2/(vt + tau2)
        H2 <- tau2/vt + 1
        if (verbose > 1) 
            message(mstyle$message("Conducting tests of the fixed effects ..."))
        chol.h <- try(chol(vb[btt, btt]), silent = !verbose)
        if (inherits(chol.h, "try-error") || anyNA(chol.h)) {
            warning(mstyle$warning("Cannot invert Hessian for QM test."), call. = FALSE)
            QM <- NA
        }
        else {
            QM <- as.vector(t(beta)[btt] %*% chol2inv(chol.h) %*% beta[btt])
        }
        if (!int.only && int.incl && con$scaleX) {
            mX <- rbind(c(intrcpt = 1, -1 * ifelse(is.d[-1], 0, meanX/sdX)), cbind(0, diag(ifelse(is.d[-1], 1, 1/sdX), nrow = length(is.d) - 1, ncol = length(is.d) - 1)))
            beta <- mX %*% beta
            vb <- mX %*% vb %*% t(mX)
            X <- Xsave
        }
        if (test == "t") {
            ddf <- k - p
        }
        else {
            ddf <- NA
        }
        if (.isTRUE(ddd$abbrev)) {
            tmp <- colnames(X)
            tmp <- gsub("relevel(factor(", "", tmp, fixed = TRUE)
            tmp <- gsub("\\), ref = \"[[:alnum:]]*\")", "", tmp)
            tmp <- gsub("poly(", "", tmp, fixed = TRUE)
            tmp <- gsub(", degree = [[:digit:]], raw = TRUE)", "^", tmp)
            tmp <- gsub(", degree = [[:digit:]], raw = T)", "^", tmp)
            tmp <- gsub(", degree = [[:digit:]])", "^", tmp)
            tmp <- gsub("rcs\\([[:alnum:]]*, [[:digit:]]\\)", "", tmp)
            tmp <- gsub("factor(", "", tmp, fixed = TRUE)
            tmp <- gsub("I(", "", tmp, fixed = TRUE)
            tmp <- gsub(")", "", tmp, fixed = TRUE)
            colnames(X) <- tmp
        }
        rownames(beta) <- rownames(vb) <- colnames(vb) <- colnames(X.f) <- colnames(X)
        ve <- diag(vb)
        se <- ifelse(ve >= 0, sqrt(ve), NA)
        names(se) <- NULL
        zval <- c(beta/se)
        if (test == "t") {
            QM <- QM/m
            QMdf <- c(m, k - p)
            QMp <- if (QMdf[2] > 0) 
                pf(QM, df1 = QMdf[1], df2 = QMdf[2], lower.tail = FALSE)
            else NA
            pval <- if (ddf > 0) 
                2 * pt(abs(zval), df = ddf, lower.tail = FALSE)
            else rep(NA, p)
            crit <- if (ddf > 0) 
                qt(level/2, df = ddf, lower.tail = FALSE)
            else rep(NA, p)
        }
        else {
            QMdf <- c(m, NA)
            QMp <- pchisq(QM, df = QMdf[1], lower.tail = FALSE)
            pval <- 2 * pnorm(abs(zval), lower.tail = FALSE)
            crit <- qnorm(level/2, lower.tail = FALSE)
        }
        ci.lb <- c(beta - crit * se)
        ci.ub <- c(beta + crit * se)
        if (verbose > 1) 
            message(mstyle$message("Computing fit statistics and log likelihood ..."))
        ll.ML <- ifelse(is.element(method, c("FE", "EE", "CE")), ll.FE, ll.ML)
        ll.REML <- NA
        dev.ML <- -2 * (ll.ML - ll.QE)
        AIC.ML <- -2 * ll.ML + 2 * parms
        BIC.ML <- -2 * ll.ML + parms * log(k.eff)
        AICc.ML <- -2 * ll.ML + 2 * parms * max(k.eff, parms + 2)/(max(k.eff, parms + 2) - parms - 1)
        dev.REML <- NA
        AIC.REML <- NA
        BIC.REML <- NA
        AICc.REML <- NA
        fit.stats <- matrix(c(ll.ML, dev.ML, AIC.ML, BIC.ML, AICc.ML, ll.REML, dev.REML, AIC.REML, BIC.REML, AICc.REML), ncol = 2, byrow = FALSE)
        dimnames(fit.stats) <- list(c("ll", "dev", "AIC", "BIC", "AICc"), c("ML", "REML"))
        fit.stats <- data.frame(fit.stats)
        if (verbose > 1) 
            message(mstyle$message("Preparing output ..."))
        weighted <- TRUE
        if (is.null(ddd$outlist) || ddd$outlist == "nodata") {
            outdat <- list(ai = ai, bi = bi, ci = ci, di = di, x1i = x1i, x2i = x2i, t1i = t1i, t2i = t2i, xi = xi, mi = mi, ti = ti)
            res <- list(b = beta, beta = beta, se = se, zval = zval, pval = pval, ci.lb = ci.lb, ci.ub = ci.ub, vb = vb, tau2 = tau2, se.tau2 = se.tau2, sigma2 = sigma2, rho = rho, ci.lb.tau2 = ci.lb.tau2, ci.ub.tau2 = ci.ub.tau2, I2 = I2, H2 = H2, vt = vt, QE.Wld = QE.Wld, QEp.Wld = QEp.Wld, QE.LRT = QE.LRT, QEp.LRT = QEp.LRT, QE.df = QE.df, QM = QM, QMdf = QMdf, QMp = QMp, k = k, k.f = k.f, k.yi = k.yi, k.eff = k.eff, k.all = k.all, p = p, p.eff = p.eff, parms = parms, int.only = int.only, int.incl = int.incl, 
                intercept = intercept, yi = yi, vi = vi, X = X, yi.f = yi.f, vi.f = vi.f, X.f = X.f, outdat.f = outdat.f, outdat = outdat, ni = ni, ni.f = ni.f, ids = ids, not.na = not.na, subset = subset, not.na.yivi = not.na.yivi, slab = slab, slab.null = slab.null, measure = measure, method = method, model = model, weighted = weighted, test = test, dfs = ddf, ddf = ddf, btt = btt, m = m, digits = digits, level = level, control = control, verbose = verbose, add = add, to = to, drop00 = drop00, 
                fit.stats = fit.stats, se.warn = se.warn, formula.yi = NULL, formula.mods = formula.mods, version = packageVersion("metafor"), call = mf)
            if (is.null(ddd$outlist)) 
                res <- append(res, list(data = data), which(names(res) == "fit.stats"))
        }
        else {
            if (ddd$outlist == "minimal") {
                res <- list(b = beta, beta = beta, se = se, zval = zval, pval = pval, ci.lb = ci.lb, ci.ub = ci.ub, vb = vb, tau2 = tau2, se.tau2 = se.tau2, sigma2 = sigma2, I2 = I2, H2 = H2, QE.Wld = QE.Wld, QEp.Wld = QEp.Wld, QE.LRT = QE.LRT, QEp.LRT = QEp.LRT, QE.df = QE.df, QEp = QEp, QM = QM, QMdf = QMdf, QMp = QMp, k = k, k.eff = k.eff, p = p, p.eff = p.eff, parms = parms, int.only = int.only, measure = measure, method = method, model = model, test = test, dfs = ddf, ddf = ddf, btt = btt, m = m, 
                  digits = digits, fit.stats = fit.stats)
            }
            else {
                res <- eval(str2lang(paste0("list(", ddd$outlist, ")")))
            }
        }
        if (.isTRUE(ddd$retfit)) {
            res$res.FE <- res.FE
            if (!isTRUE(ddd$skiphet)) 
                res$res.QE <- res.QE
            if (method == "ML") 
                res$res.ML <- res.ML
        }
        time.end <- proc.time()
        res$time <- unname(time.end - time.start)[3]
        if (.isTRUE(ddd$time)) 
            .print.time(res$time)
        if (verbose || .isTRUE(ddd$time)) 
            cat("\n")
        class(res) <- c("rma.glmm", "rma")
        return(res)
    })(xi = c(0, 5, 21, 2, 0, 215), ni = c(50, 48, 250, 459, 109, 4177), measure = "PLO", method = "FE", test = "z", level = 95), time = 0.00599999999985812)
list(b = -3.98321221538343, beta = -3.98321221538343, se = 0.786991537927107, zval = -5.06131517738424, pval = 4.16374246268764e-07, ci.lb = -5.52568728585835, ci.ub = -2.44073714490851, vb = 0.619355680768873, tau2 = 2.50980755030703, se.tau2 = NA, sigma2 = NA, rho = NA, ci.lb.tau2 = NA, ci.ub.tau2 = NA, I2 = 96.0620343765155, H2 = 25.3938224863214, vt = 0.10288701378041, QE.Wld = 20.204707412439, QEp.Wld = 0.00114386456629603, QE.LRT = 56.4490254004094, QEp.LRT = 6.56784938424704e-11, QE.df = 5, 
    QM = 25.6169113248201, QMdf = c(1, NA), QMp = 4.16374246268765e-07, k = 6, k.f = 6, k.yi = 6, k.eff = 6, k.all = 6, p = 1, p.eff = 1, parms = 2, int.only = TRUE, int.incl = TRUE, intercept = TRUE, yi = c(-4.61512051684126, -2.15176220325946, -2.38919956583082, -5.43153621033426, -5.3890717298165, -2.91386619913083), vi = c(2.01980198019802, 0.223255813953488, 0.0519858598461218, 0.50218818380744, 2.00913242009132, 0.00490356056959722), X = c(1, 1, 1, 1, 1, 1), yi.f = c(-4.61512051684126, -2.15176220325946, 
    -2.38919956583082, -5.43153621033426, -5.3890717298165, -2.91386619913083), vi.f = c(2.01980198019802, 0.223255813953488, 0.0519858598461218, 0.50218818380744, 2.00913242009132, 0.00490356056959722), X.f = c(1, 1, 1, 1, 1, 1), outdat.f = list(ai = NA, bi = NA, ci = NA, di = NA, x1i = NA, x2i = NA, t1i = NA, t2i = NA, xi = c(0, 5, 21, 2, 0, 215), mi = c(50, 43, 229, 457, 109, 3962), ni = c(50, 48, 250, 459, 109, 4177), ti = NA), outdat = list(ai = NA, bi = NA, ci = NA, di = NA, x1i = NA, x2i = NA, 
        t1i = NA, t2i = NA, xi = c(0, 5, 21, 2, 0, 215), mi = c(50, 43, 229, 457, 109, 3962), ti = NA), ni = c(50, 48, 250, 459, 109, 4177), ni.f = c(50, 48, 250, 459, 109, 4177), ids = 1:6, not.na = c(TRUE, TRUE, TRUE, TRUE, TRUE, TRUE), subset = NULL, not.na.yivi = c(TRUE, TRUE, TRUE, TRUE, TRUE, TRUE), slab = 1:6, slab.null = TRUE, measure = "PLO", method = "ML", model = "UM.FS", weighted = TRUE, test = "z", dfs = NA, ddf = NA, btt = 1, m = 1, digits = c(est = 4, se = 4, test = 4, pval = 4, ci = 4, 
    var = 4, sevar = 4, fit = 4, het = 4), level = 0.05, control = list(), verbose = FALSE, add = 0.5, to = "only0", drop00 = TRUE, fit.stats = list(ML = c(-9.98821212309484, 2.03697089437608, 23.9764242461897, 23.5599431846458, 27.9764242461897), REML = c(NA, NA, NA, NA, NA)), data = <environment>, se.warn = FALSE, formula.yi = NULL, formula.mods = NULL, version = list(c(4, 4, 0)), call = (function (ai, bi, ci, di, n1i, n2i, x1i, x2i, t1i, t2i, xi, mi, ti, ni, mods, measure, intercept = TRUE, data, 
        slab, subset, add = 1/2, to = "only0", drop00 = TRUE, vtype = "LS", model = "UM.FS", method = "ML", coding = 1/2, cor = FALSE, test = "z", level = 95, btt, nAGQ = 7, verbose = FALSE, digits, control, ...) 
    {
        mstyle <- .get.mstyle("crayon" %in% .packages())
        if (missing(measure)) 
            stop(mstyle$stop("Must specify 'measure' argument."))
        if (!is.element(measure, c("OR", "IRR", "PLO", "IRLN", "PR", "RR", "RD", "PLN"))) 
            stop(mstyle$stop("Unknown 'measure' specified."))
        if (!is.element(method, c("FE", "EE", "CE", "ML"))) 
            stop(mstyle$stop("Unknown 'method' specified."))
        if (!is.element(coding, c(1/2, 1, 0))) 
            stop(mstyle$stop("Unknown 'coding' option specified."))
        if (length(add) > 1) 
            add <- add[1]
        if (length(to) > 1) 
            to <- to[1]
        if (!is.element(model, c("UM.FS", "UM.RS", "CM.EL", "CM.AL"))) 
            stop(mstyle$stop("Unknown 'model' specified."))
        if (model == "CM.AL" && measure == "IRR") 
            model <- "CM.EL"
        if (is.element(measure, c("PLO", "PR", "PLN", "IRLN")) && !is.null(match.call()$model)) 
            warning(mstyle$warning("Argument 'model' not relevant for this outcome measure."), call. = FALSE)
        if (!is.element(measure, c("OR", "IRR", "PLO", "IRLN"))) 
            warning(mstyle$warning("The use of this 'measure' is experimental - treat results with caution."), call. = FALSE)
        if (is.element(model, c("CM.EL", "CM.AL")) && is.element(measure, c("RR", "RD"))) 
            stop(mstyle$stop("Cannot use this measure with model='CM.EL' or model='CM.AL'."))
        na.act <- getOption("na.action")
        on.exit(options(na.action = na.act), add = TRUE)
        if (!is.element(na.act, c("na.omit", "na.exclude", "na.fail", "na.pass"))) 
            stop(mstyle$stop("Unknown 'na.action' specified under options()."))
        if (missing(control)) 
            control <- list()
        time.start <- proc.time()
        ddd <- list(...)
        .chkdots(ddd, c("tdist", "outlist", "onlyo1", "addyi", "addvi", "time", "retdat", "family", "retfit", "skiphet", "i2def", "link"))
        if (.isFALSE(ddd$tdist)) 
            test <- "z"
        if (.isTRUE(ddd$tdist)) 
            test <- "t"
        if (!is.element(test, c("z", "t"))) 
            stop(mstyle$stop("Invalid option selected for 'test' argument."))
        onlyo1 <- ifelse(is.null(ddd$onlyo1), FALSE, ddd$onlyo1)
        addyi <- ifelse(is.null(ddd$addyi), TRUE, ddd$addyi)
        addvi <- ifelse(is.null(ddd$addvi), TRUE, ddd$addvi)
        i2def <- ifelse(is.null(ddd$i2def), "1", ddd$i2def)
        if (missing(digits)) {
            digits <- .set.digits(dmiss = TRUE)
        }
        else {
            digits <- .set.digits(digits, dmiss = FALSE)
        }
        formula.mods <- NULL
        if (verbose > 2) {
            opwarn <- options(warn = 1)
            on.exit(options(warn = opwarn$warn), add = TRUE)
        }
        if (is.null(ddd$link)) {
            if (measure == "OR" || measure == "PLO") 
                link <- "logit"
            if (measure == "RR" || measure == "PLN") 
                link <- "log"
            if (measure == "RD" || measure == "PR") 
                link <- "identity"
            if (measure == "IRR" || measure == "IRLN") 
                link <- "log"
        }
        else {
            link <- ddd$link
        }
        if (verbose) 
            .space()
        if (verbose > 1) 
            message(mstyle$message("Extracting data and computing yi/vi values ..."))
        if (missing(data)) 
            data <- NULL
        if (is.null(data)) {
            data <- sys.frame(sys.parent())
        }
        else {
            if (!is.data.frame(data)) 
                data <- data.frame(data)
        }
        mf <- match.call()
        slab <- .getx("slab", mf = mf, data = data)
        subset <- .getx("subset", mf = mf, data = data)
        mods <- .getx("mods", mf = mf, data = data)
        ai <- bi <- ci <- di <- x1i <- x2i <- t1i <- t2i <- xi <- mi <- ti <- NA
        if (is.element(measure, c("OR", "RR", "RD"))) {
            ai <- .getx("ai", mf = mf, data = data, checknumeric = TRUE)
            bi <- .getx("bi", mf = mf, data = data, checknumeric = TRUE)
            ci <- .getx("ci", mf = mf, data = data, checknumeric = TRUE)
            di <- .getx("di", mf = mf, data = data, checknumeric = TRUE)
            n1i <- .getx("n1i", mf = mf, data = data, checknumeric = TRUE)
            n2i <- .getx("n2i", mf = mf, data = data, checknumeric = TRUE)
            if (is.null(bi)) 
                bi <- n1i - ai
            if (is.null(di)) 
                di <- n2i - ci
            k <- length(ai)
            k.all <- k
            if (!is.null(subset)) {
                subset <- .chksubset(subset, k)
                ai <- .getsubset(ai, subset)
                bi <- .getsubset(bi, subset)
                ci <- .getsubset(ci, subset)
                di <- .getsubset(di, subset)
            }
            args <- list(measure = measure, ai = ai, bi = bi, ci = ci, di = di, add = add, to = to, drop00 = drop00, vtype = vtype, onlyo1 = onlyo1, addyi = addyi, addvi = addvi)
        }
        if (is.element(measure, c("IRR"))) {
            x1i <- .getx("x1i", mf = mf, data = data, checknumeric = TRUE)
            x2i <- .getx("x2i", mf = mf, data = data, checknumeric = TRUE)
            t1i <- .getx("t1i", mf = mf, data = data, checknumeric = TRUE)
            t2i <- .getx("t2i", mf = mf, data = data, checknumeric = TRUE)
            k <- length(x1i)
            k.all <- k
            if (!is.null(subset)) {
                subset <- .chksubset(subset, k)
                x1i <- .getsubset(x1i, subset)
                x2i <- .getsubset(x2i, subset)
                t1i <- .getsubset(t1i, subset)
                t2i <- .getsubset(t2i, subset)
            }
            args <- list(measure = measure, x1i = x1i, x2i = x2i, t1i = t1i, t2i = t2i, add = add, to = to, drop00 = drop00, vtype = vtype, onlyo1 = onlyo1, addyi = addyi, addvi = addvi)
        }
        if (is.element(measure, c("PLO", "PR", "PLN"))) {
            xi <- .getx("xi", mf = mf, data = data, checknumeric = TRUE)
            mi <- .getx("mi", mf = mf, data = data, checknumeric = TRUE)
            ni <- .getx("ni", mf = mf, data = data, checknumeric = TRUE)
            if (is.null(mi)) 
                mi <- ni - xi
            k <- length(xi)
            k.all <- k
            if (!is.null(subset)) {
                subset <- .chksubset(subset, k)
                xi <- .getsubset(xi, subset)
                mi <- .getsubset(mi, subset)
            }
            args <- list(measure = measure, xi = xi, mi = mi, add = add, to = to, vtype = vtype, onlyo1 = onlyo1, addyi = addyi, addvi = addvi)
        }
        if (is.element(measure, c("IRLN"))) {
            xi <- .getx("xi", mf = mf, data = data, checknumeric = TRUE)
            ti <- .getx("ti", mf = mf, data = data, checknumeric = TRUE)
            k <- length(xi)
            k.all <- k
            if (!is.null(subset)) {
                subset <- .chksubset(subset, k)
                xi <- .getsubset(xi, subset)
                ti <- .getsubset(ti, subset)
            }
            args <- list(measure = measure, xi = xi, ti = ti, add = add, to = to, vtype = vtype, onlyo1 = onlyo1, addyi = addyi, addvi = addvi)
        }
        dat <- .do.call(escalc, args)
        yi <- dat$yi
        vi <- dat$vi
        ni <- attr(yi, "ni")
        ids <- seq_len(k)
        if (verbose > 1) 
            message(mstyle$message("Creating model matrix ..."))
        if (inherits(mods, "formula")) {
            formula.mods <- mods
            if (isTRUE(all.equal(formula.mods, ~1))) {
                mods <- matrix(1, nrow = k, ncol = 1)
                intercept <- FALSE
            }
            else {
                options(na.action = "na.pass")
                mods <- model.matrix(mods, data = data)
                attr(mods, "assign") <- NULL
                options(na.action = na.act)
                intercept <- FALSE
            }
        }
        if (.is.vector(mods)) 
            mods <- cbind(mods)
        if (is.data.frame(mods)) 
            mods <- as.matrix(mods)
        if (is.character(mods)) 
            stop(mstyle$stop("Model matrix contains character variables."))
        if (!is.null(mods) && nrow(mods) != k) 
            stop(mstyle$stop(paste0("Number of rows in the model matrix (", nrow(mods), ") does not match length of the outcome vector (", k, ").")))
        if (verbose > 1) 
            message(mstyle$message("Generating/extracting study labels ..."))
        if (is.null(slab)) {
            slab.null <- TRUE
            slab <- ids
        }
        else {
            if (anyNA(slab)) 
                stop(mstyle$stop("NAs in study labels."))
            if (length(slab) != k) 
                stop(mstyle$stop("Study labels not of same length as data."))
            if (is.factor(slab)) 
                slab <- as.character(slab)
            slab.null <- FALSE
        }
        if (!is.null(subset)) {
            if (verbose > 1) 
                message(mstyle$message("Subsetting ..."))
            mods <- .getsubset(mods, subset)
            slab <- .getsubset(slab, subset)
            ids <- .getsubset(ids, subset)
        }
        if (anyDuplicated(slab)) 
            slab <- .make.unique(slab)
        attr(yi, "slab") <- slab
        k <- length(yi)
        if (is.element(measure, c("OR", "RR", "RD"))) {
            if (drop00) {
                id00 <- c(ai == 0 & ci == 0) | c(bi == 0 & di == 0)
                id00[is.na(id00)] <- FALSE
                ai[id00] <- NA
                bi[id00] <- NA
                ci[id00] <- NA
                di[id00] <- NA
            }
        }
        if (is.element(measure, c("IRR"))) {
            if (drop00) {
                id00 <- c(x1i == 0 & x2i == 0)
                id00[is.na(id00)] <- FALSE
                x1i[id00] <- NA
                x2i[id00] <- NA
            }
        }
        outdat.f <- list(ai = ai, bi = bi, ci = ci, di = di, x1i = x1i, x2i = x2i, t1i = t1i, t2i = t2i, xi = xi, mi = mi, ni = ni, ti = ti)
        yi.f <- yi
        vi.f <- vi
        ni.f <- ni
        mods.f <- mods
        k.f <- k
        if (is.element(measure, c("OR", "RR", "RD"))) {
            has.na <- is.na(ai) | is.na(bi) | is.na(ci) | is.na(di) | (if (is.null(mods)) 
                FALSE
            else apply(is.na(mods), 1, any))
            not.na <- !has.na
            if (any(has.na)) {
                if (verbose > 1) 
                  message(mstyle$message("Handling NAs in table data ..."))
                if (na.act == "na.omit" || na.act == "na.exclude" || na.act == "na.pass") {
                  ai <- ai[not.na]
                  bi <- bi[not.na]
                  ci <- ci[not.na]
                  di <- di[not.na]
                  mods <- mods[not.na, , drop = FALSE]
                  k <- length(ai)
                  warning(mstyle$warning(paste(sum(has.na), ifelse(sum(has.na) > 1, "studies", "study"), "with NAs omitted from model fitting.")), call. = FALSE)
                }
                if (na.act == "na.fail") 
                  stop(mstyle$stop("Missing values in studies."))
            }
        }
        if (is.element(measure, "IRR")) {
            has.na <- is.na(x1i) | is.na(x2i) | is.na(t1i) | is.na(t2i) | (if (is.null(mods)) 
                FALSE
            else apply(is.na(mods), 1, any))
            not.na <- !has.na
            if (any(has.na)) {
                if (verbose > 1) 
                  message(mstyle$message("Handling NAs in table data ..."))
                if (na.act == "na.omit" || na.act == "na.exclude" || na.act == "na.pass") {
                  x1i <- x1i[not.na]
                  x2i <- x2i[not.na]
                  t1i <- t1i[not.na]
                  t2i <- t2i[not.na]
                  mods <- mods[not.na, , drop = FALSE]
                  k <- length(x1i)
                  warning(mstyle$warning(paste(sum(has.na), ifelse(sum(has.na) > 1, "studies", "study"), "with NAs omitted from model fitting.")), call. = FALSE)
                }
                if (na.act == "na.fail") 
                  stop(mstyle$stop("Missing values in studies."))
            }
        }
        if (is.element(measure, c("PLO", "PR", "PLN"))) {
            has.na <- is.na(xi) | is.na(mi) | (if (is.null(mods)) 
                FALSE
            else apply(is.na(mods), 1, any))
            not.na <- !has.na
            if (any(has.na)) {
                if (verbose > 1) 
                  message(mstyle$message("Handling NAs in table data ..."))
                if (na.act == "na.omit" || na.act == "na.exclude" || na.act == "na.pass") {
                  xi <- xi[not.na]
                  mi <- mi[not.na]
                  mods <- mods[not.na, , drop = FALSE]
                  k <- length(xi)
                  warning(mstyle$warning(paste(sum(has.na), ifelse(sum(has.na) > 1, "studies", "study"), "with NAs omitted from model fitting.")), call. = FALSE)
                }
                if (na.act == "na.fail") 
                  stop(mstyle$stop("Missing values in studies."))
            }
        }
        if (is.element(measure, "IRLN")) {
            has.na <- is.na(xi) | is.na(ti) | (if (is.null(mods)) 
                FALSE
            else apply(is.na(mods), 1, any))
            not.na <- !has.na
            if (any(has.na)) {
                if (verbose > 1) 
                  message(mstyle$message("Handling NAs in table data ..."))
                if (na.act == "na.omit" || na.act == "na.exclude" || na.act == "na.pass") {
                  xi <- xi[not.na]
                  ti <- ti[not.na]
                  mods <- mods[not.na, , drop = FALSE]
                  k <- length(xi)
                  warning(mstyle$warning(paste(sum(has.na), ifelse(sum(has.na) > 1, "studies", "study"), "with NAs omitted from model fitting.")), call. = FALSE)
                }
                if (na.act == "na.fail") 
                  stop(mstyle$stop("Missing values in studies."))
            }
        }
        if (k < 1) 
            stop(mstyle$stop("Processing terminated since k = 0."))
        mods.yi <- mods.f
        yivi.na <- is.na(yi) | is.na(vi) | (if (is.null(mods.yi)) 
            FALSE
        else apply(is.na(mods.yi), 1, any))
        not.na.yivi <- !yivi.na
        if (any(yivi.na)) {
            if (verbose > 1) 
                message(mstyle$message("Handling NAs in yi/vi ..."))
            if (na.act == "na.omit" || na.act == "na.exclude" || na.act == "na.pass") {
                yi <- yi[not.na.yivi]
                ni <- ni[not.na.yivi]
                vi <- vi[not.na.yivi]
                mods.yi <- mods.f[not.na.yivi, , drop = FALSE]
                warning(mstyle$warning("Some yi/vi values are NA."), call. = FALSE)
                attr(yi, "measure") <- measure
                attr(yi, "ni") <- ni
            }
            if (na.act == "na.fail") 
                stop(mstyle$stop("Missing yi/vi values."))
        }
        k.yi <- length(yi)
        if (is.null(mods) && !intercept) {
            warning(mstyle$warning("Must either include an intercept and/or moderators in model.\nCoerced intercept into the model."), call. = FALSE)
            intercept <- TRUE
        }
        if (!is.null(mods) && ncol(mods) == 0) {
            warning(mstyle$warning("Cannot fit model with an empty model matrix. Coerced intercept into the model."), call. = FALSE)
            intercept <- TRUE
        }
        if (intercept) {
            X <- cbind(intrcpt = rep(1, k), mods)
            X.f <- cbind(intrcpt = rep(1, k.f), mods.f)
            X.yi <- cbind(intrcpt = rep(1, k.yi), mods.yi)
        }
        else {
            X <- mods
            X.f <- mods.f
            X.yi <- mods.yi
        }
        tmp <- lm(rep(0, k) ~ X - 1)
        coef.na <- is.na(coef(tmp))
        if (any(coef.na)) {
            warning(mstyle$warning("Redundant predictors dropped from the model."), call. = FALSE)
            X <- X[, !coef.na, drop = FALSE]
            X.f <- X.f[, !coef.na, drop = FALSE]
        }
        tmp <- lm(yi ~ X.yi - 1)
        coef.na <- is.na(coef(tmp))
        if (any(coef.na)) 
            X.yi <- X.yi[, !coef.na, drop = FALSE]
        is.int <- apply(X, 2, .is.intercept)
        if (any(is.int)) {
            int.incl <- TRUE
            int.indx <- which(is.int, arr.ind = TRUE)
            X <- cbind(intrcpt = 1, X[, -int.indx, drop = FALSE])
            X.f <- cbind(intrcpt = 1, X.f[, -int.indx, drop = FALSE])
            intercept <- TRUE
        }
        else {
            int.incl <- FALSE
        }
        is.int <- apply(X.yi, 2, .is.intercept)
        if (any(is.int)) {
            int.indx <- which(is.int, arr.ind = TRUE)
            X.yi <- cbind(intrcpt = 1, X.yi[, -int.indx, drop = FALSE])
        }
        p <- NCOL(X)
        colnames(X) <- colnames(X.f) <- .make.unique(colnames(X))
        if ((p == 1) && .is.intercept(X)) {
            int.only <- TRUE
        }
        else {
            int.only <- FALSE
        }
        if (is.element(method, c("FE", "EE", "CE")) && p > k) 
            stop(mstyle$stop("Number of parameters to be estimated is larger than the number of observations."))
        if (!is.element(method, c("FE", "EE", "CE")) && (p + 1) > k) 
            stop(mstyle$stop("Number of parameters to be estimated is larger than the number of observations."))
        btt <- .set.btt(btt, p, int.incl, colnames(X))
        m <- length(btt)
        con <- list(verbose = FALSE, package = "lme4", optimizer = "nlminb", optmethod = "BFGS", parallel = list(), cl = NULL, ncpus = 1, scaleX = TRUE, evtol = 1e-07, dnchgcalc = "dFNCHypergeo", dnchgprec = 1e-10, hesspack = "numDeriv", tau2tol = 1e-04)
        con.pos <- pmatch(names(control), names(con))
        con[c(na.omit(con.pos))] <- control[!is.na(con.pos)]
        if (verbose) 
            con$verbose <- verbose
        verbose <- con$verbose
        optimizer <- match.arg(con$optimizer, c("optim", "nlminb", "uobyqa", "newuoa", "bobyqa", "nloptr", "nlm", "hjk", "nmk", "mads", "ucminf", "lbfgsb3c", "subplex", "BBoptim", "optimParallel", "clogit", "clogistic", "Nelder-Mead", "BFGS", "CG", "L-BFGS-B", "SANN", "Brent", "Rcgmin", "Rvmmin"))
        optmethod <- match.arg(con$optmethod, c("Nelder-Mead", "BFGS", "CG", "L-BFGS-B", "SANN", "Brent"))
        if (optimizer %in% c("Nelder-Mead", "BFGS", "CG", "L-BFGS-B", "SANN", "Brent")) {
            optmethod <- optimizer
            optimizer <- "optim"
        }
        package <- match.arg(con$package, c("lme4", "GLMMadaptive", "glmmTMB"))
        parallel <- con$parallel
        cl <- con$cl
        ncpus <- con$ncpus
        if (con$dnchgcalc != "dnoncenhypergeom" && con$dnchgcalc != "dFNCHypergeo") 
            stop(mstyle$stop("Unknown dnchgcalc method specified."))
        if (is.element(optimizer, c("clogit", "clogistic")) && method == "ML") 
            stop(mstyle$stop("Cannot use 'clogit' or 'clogistic' with method='ML'."))
        if (package == "lme4" && is.element(measure, c("OR", "RR", "RD", "IRR")) && model == "UM.RS" && method == "ML" && nAGQ > 1) {
            warning(mstyle$warning("Not possible to fit RE/ME model='UM.RS' with nAGQ > 1 with glmer(). nAGQ automatically set to 1."), call. = FALSE)
            nAGQ <- 1
        }
        if (ncpus > 1) 
            optimizer <- "optimParallel"
        pos.optCtrl <- pmatch(names(control), "optCtrl", nomatch = 0)
        if (sum(pos.optCtrl) > 0) {
            optCtrl <- control[[which(pos.optCtrl == 1)]]
        }
        else {
            optCtrl <- list()
        }
        if (optimizer == "nloptr" && !is.element("algorithm", names(optCtrl))) 
            optCtrl$algorithm <- "NLOPT_LN_BOBYQA"
        if (optimizer == "nloptr" && !is.element("ftol_rel", names(optCtrl))) 
            optCtrl$ftol_rel <- 1e-08
        if (optimizer == "mads" && !is.element("trace", names(optCtrl))) 
            optCtrl$trace <- FALSE
        if (optimizer == "mads" && !is.element("tol", names(optCtrl))) 
            optCtrl$tol <- 1e-06
        if (optimizer == "subplex" && !is.element("reltol", names(optCtrl))) 
            optCtrl$reltol <- 1e-08
        if (optimizer == "BBoptim" && !is.element("trace", names(optCtrl))) 
            optCtrl$trace <- FALSE
        if (optimizer == "optim") {
            con.pos <- pmatch(names(optCtrl), "REPORT", nomatch = 0)
            if (sum(con.pos) > 0) {
                names(optCtrl)[which(con.pos == 1)] <- "REPORT"
            }
            else {
                optCtrl$REPORT <- 1
            }
            optCtrl$trace <- con$verbose
        }
        if (optimizer == "nlminb") 
            optCtrl$trace <- ifelse(con$verbose > 0, 1, 0)
        if (is.element(optimizer, c("uobyqa", "newuoa", "bobyqa"))) 
            optCtrl$iprint <- ifelse(con$verbose > 0, 3, 0)
        pos.clogitCtrl <- pmatch(names(control), "clogitCtrl", nomatch = 0)
        if (sum(pos.clogitCtrl) > 0) {
            clogitCtrl <- control[[which(pos.clogitCtrl == 1)]]
        }
        else {
            clogitCtrl <- list()
        }
        pos.clogisticCtrl <- pmatch(names(control), "clogisticCtrl", nomatch = 0)
        if (sum(pos.clogisticCtrl) > 0) {
            clogisticCtrl <- control[[which(pos.clogisticCtrl == 1)]]
        }
        else {
            clogisticCtrl <- list()
        }
        pos.glmCtrl <- pmatch(names(control), "glmCtrl", nomatch = 0)
        if (sum(pos.glmCtrl) > 0) {
            glmCtrl <- control[[which(pos.glmCtrl == 1)]]
        }
        else {
            glmCtrl <- list()
        }
        glmCtrl$trace <- ifelse(con$verbose > 0, TRUE, FALSE)
        pos.glmerCtrl <- pmatch(names(control), "glmerCtrl", nomatch = 0)
        if (sum(pos.glmerCtrl) > 0) {
            glmerCtrl <- control[[which(pos.glmerCtrl == 1)]]
        }
        else {
            glmerCtrl <- list()
        }
        pos.intCtrl <- pmatch(names(control), "intCtrl", nomatch = 0)
        if (sum(pos.intCtrl) > 0) {
            intCtrl <- control[[which(pos.intCtrl == 1)]]
        }
        else {
            intCtrl <- list()
        }
        con.pos <- pmatch(names(intCtrl), "lower", nomatch = 0)
        if (sum(con.pos) > 0) {
            names(intCtrl)[which(con.pos == 1)] <- "lower"
        }
        else {
            intCtrl$lower <- -Inf
        }
        con.pos <- pmatch(names(intCtrl), "upper", nomatch = 0)
        if (sum(con.pos) > 0) {
            names(intCtrl)[which(con.pos == 1)] <- "upper"
        }
        else {
            intCtrl$upper <- Inf
        }
        con.pos <- pmatch(names(intCtrl), "subdivisions", nomatch = 0)
        if (sum(con.pos) > 0) {
            names(intCtrl)[which(con.pos == 1)] <- "subdivisions"
        }
        else {
            intCtrl$subdivisions <- 100
        }
        con.pos <- pmatch(names(intCtrl), "rel.tol", nomatch = 0)
        if (sum(con.pos) > 0) {
            names(intCtrl)[which(con.pos == 1)] <- "rel.tol"
        }
        else {
            intCtrl$rel.tol <- .Machine$double.eps^0.25
        }
        pos.hessianCtrl <- pmatch(names(control), "hessianCtrl", nomatch = 0)
        if (sum(pos.hessianCtrl) > 0) {
            hessianCtrl <- control[[which(pos.hessianCtrl == 1)]]
        }
        else {
            hessianCtrl <- list(r = 16)
        }
        if (is.element(measure, c("OR", "RR", "RD", "IRR"))) {
            if ((model == "UM.FS" && method == "ML") || (model == "UM.RS") || (model == "CM.AL" && method == "ML") || (model == "CM.EL" && method == "ML")) {
                if (!requireNamespace(package, quietly = TRUE)) 
                  stop(mstyle$stop(paste0("Please install the '", package, "' package to fit this model.")))
            }
        }
        if (is.element(measure, c("PLO", "PR", "PLN", "IRLN")) && method == "ML") {
            if (!requireNamespace(package, quietly = TRUE)) 
                stop(mstyle$stop(paste0("Please install the '", package, "' package to fit this model.")))
        }
        if (measure == "OR" && model == "CM.EL") {
            if (is.element(optimizer, c("uobyqa", "newuoa", "bobyqa"))) {
                if (!requireNamespace("minqa", quietly = TRUE)) 
                  stop(mstyle$stop("Please install the 'minqa' package to fit this model."))
            }
            if (is.element(optimizer, c("nloptr", "ucminf", "lbfgsb3c", "subplex", "optimParallel"))) {
                if (!requireNamespace(optimizer, quietly = TRUE)) 
                  stop(mstyle$stop(paste0("Please install the '", optimizer, "' package to use this optimizer.")))
            }
            if (is.element(optimizer, c("hjk", "nmk", "mads"))) {
                if (!requireNamespace("dfoptim", quietly = TRUE)) 
                  stop(mstyle$stop("Please install the 'dfoptim' package to use this optimizer."))
            }
            if (optimizer == "BBoptim") {
                if (!requireNamespace("BB", quietly = TRUE)) 
                  stop(mstyle$stop("Please install the 'BB' package to use this optimizer."))
            }
            if (is.element(optimizer, c("optim", "nlminb", "uobyqa", "newuoa", "bobyqa", "nloptr", "nlm", "hjk", "nmk", "mads", "ucminf", "lbfgsb3c", "subplex", "BBoptim", "optimParallel", "Rcgmin", "Rvmmin"))) {
                con$hesspack <- match.arg(con$hesspack, c("numDeriv", "pracma"))
                if (!requireNamespace(con$hesspack, quietly = TRUE)) 
                  stop(mstyle$stop(paste0("Please install the '", con$hesspack, "' package to fit this model.")))
                if (con$dnchgcalc == "dFNCHypergeo") {
                  if (!requireNamespace("BiasedUrn", quietly = TRUE)) 
                    stop(mstyle$stop("Please install the 'BiasedUrn' package to fit this model."))
                }
            }
            if (optimizer == "clogit") {
                if (!requireNamespace("survival", quietly = TRUE)) 
                  stop(mstyle$stop("Please install the 'survival' package to fit this model."))
                coxph <- survival::coxph
                Surv <- survival::Surv
                clogit <- survival::clogit
                strata <- survival::strata
            }
            if (optimizer == "clogistic") {
                if (!requireNamespace("Epi", quietly = TRUE)) 
                  stop(mstyle$stop("Please install the 'Epi' package to fit this model."))
            }
        }
        if (!.chkpd(crossprod(X), tol = con$evtol)) 
            stop(mstyle$stop("Model matrix not of full rank. Cannot fit model."))
        se.tau2 <- ci.lb.tau2 <- ci.ub.tau2 <- I2 <- H2 <- QE <- QEp <- NA
        se.warn <- FALSE
        rho <- NA
        level <- .level(level)
        if (!int.only && int.incl && con$scaleX) {
            Xsave <- X
            meanX <- colMeans(X[, 2:p, drop = FALSE])
            sdX <- apply(X[, 2:p, drop = FALSE], 2, sd)
            is.d <- apply(X, 2, .is.dummy)
            X[, !is.d] <- apply(X[, !is.d, drop = FALSE], 2, scale)
        }
        if (is.element(measure, c("OR", "RR", "RD", "IRR"))) {
            if (is.element(model, c("UM.FS", "UM.RS"))) {
                if (is.element(measure, c("OR", "RR", "RD"))) {
                  dat.grp <- cbind(xi = c(rbind(ai, ci)), mi = c(rbind(bi, di)))
                  if (is.null(ddd$family)) {
                    if (measure == "OR") 
                      dat.fam <- binomial(link = link)
                    if (measure == "RR") 
                      dat.fam <- binomial(link = link)
                    if (measure == "RD") 
                      dat.fam <- binomial(link = link)
                  }
                  else {
                    dat.fam <- ddd$family
                  }
                  dat.off <- NULL
                }
                if (is.element(measure, c("IRR"))) {
                  dat.grp <- c(rbind(x1i, x2i))
                  if (is.null(ddd$family)) {
                    dat.fam <- poisson(link = link)
                  }
                  else {
                    dat.fam <- ddd$family
                  }
                  dat.off <- log(c(rbind(t1i, t2i)))
                }
                group1 <- rep(c(1, 0), times = k)
                group2 <- rep(c(0, 1), times = k)
                group12 <- rep(c(1/2, -1/2), times = k)
                study <- factor(rep(seq_len(k), each = 2))
                const <- cbind(rep(1, 2 * k))
                X.fit <- X[rep(seq(k), each = 2), , drop = FALSE]
                X.fit <- cbind(group1 * X.fit[, , drop = FALSE])
                if (coding == 1/2) 
                  group <- group12
                if (coding == 1) 
                  group <- group1
                if (coding == 0) 
                  group <- group2
                rownames(X.fit) <- seq_len(2 * k)
                if (.isTRUE(ddd$retdat)) 
                  return(list(dat.grp = dat.grp, X.fit = X.fit, study = study, dat.off = if (!is.null(dat.off)) dat.off else NULL, const = const, group1 = group1, group2 = group2, group12 = group12, group = group, dat.fam = dat.fam))
                if (model == "UM.FS") {
                  if (verbose) 
                    message(mstyle$message("Fitting FE model ..."))
                  if (k > 1) {
                    res.FE <- try(glm(dat.grp ~ -1 + X.fit + study, offset = dat.off, family = dat.fam, control = glmCtrl), silent = !verbose)
                  }
                  else {
                    res.FE <- try(glm(dat.grp ~ -1 + X.fit + const, offset = dat.off, family = dat.fam, control = glmCtrl), silent = !verbose)
                  }
                  if (inherits(res.FE, "try-error")) 
                    stop(mstyle$stop(paste0("Cannot fit FE model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))))
                  ll.FE <- c(logLik(res.FE))
                  QEconv <- FALSE
                  ll.QE <- NA
                  if (!isTRUE(ddd$skiphet)) {
                    if (k > 1 && verbose) 
                      message(mstyle$message("Fitting saturated model ..."))
                    if (k > 1) {
                      X.QE <- model.matrix(~-1 + X.fit + study + study:group1)
                      res.QE <- try(glm(dat.grp ~ -1 + X.QE, offset = dat.off, family = dat.fam, control = glmCtrl), silent = !verbose)
                    }
                    else {
                      res.QE <- res.FE
                    }
                    if (inherits(res.QE, "try-error")) {
                      warning(mstyle$warning(paste0("Cannot fit saturated model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))), call. = FALSE)
                    }
                    else {
                      QEconv <- TRUE
                      ll.QE <- c(logLik(res.QE))
                      b2.QE <- cbind(coef(res.QE, complete = FALSE)[-seq_len(k + p)])
                      vb2.QE <- vcov(res.QE, complete = FALSE)[-seq_len(k + p), -seq_len(k + p), drop = FALSE]
                    }
                  }
                  if (method == "ML") {
                    if (verbose) 
                      message(mstyle$message("Fitting ML model ..."))
                    if (package == "lme4") {
                      if (verbose) {
                        res.ML <- try(lme4::glmer(dat.grp ~ -1 + X.fit + study + (group - 1 | study), offset = dat.off, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = do.call(lme4::glmerControl, glmerCtrl)), silent = !verbose)
                      }
                      else {
                        res.ML <- suppressMessages(try(lme4::glmer(dat.grp ~ -1 + X.fit + study + (group - 1 | study), offset = dat.off, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = do.call(lme4::glmerControl, glmerCtrl)), silent = !verbose))
                      }
                    }
                    if (package == "GLMMadaptive") {
                      if (is.element(measure, c("OR", "RR", "RD"))) {
                        dat.mm <- data.frame(xi = dat.grp[, "xi"], mi = dat.grp[, "mi"], study = study, group = group)
                        res.ML <- try(GLMMadaptive::mixed_model(cbind(xi, mi) ~ -1 + X.fit + study, random = ~group - 1 | study, data = dat.mm, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = glmerCtrl), silent = !verbose)
                      }
                      else {
                        dat.mm <- data.frame(xi = dat.grp, study = study, group = group)
                        res.ML <- try(GLMMadaptive::mixed_model(xi ~ -1 + X.fit + study + offset(dat.off), random = ~group - 1 | study, data = dat.mm, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = glmerCtrl), silent = !verbose)
                      }
                    }
                    if (package == "glmmTMB") {
                      if (verbose) {
                        res.ML <- try(glmmTMB::glmmTMB(dat.grp ~ -1 + X.fit + study + (group - 1 | study), offset = dat.off, family = dat.fam, verbose = verbose, data = NULL, control = do.call(glmmTMB::glmmTMBControl, glmerCtrl)), silent = !verbose)
                      }
                      else {
                        res.ML <- suppressMessages(try(glmmTMB::glmmTMB(dat.grp ~ -1 + X.fit + study + (group - 1 | study), offset = dat.off, family = dat.fam, verbose = verbose, data = NULL, control = do.call(glmmTMB::glmmTMBControl, glmerCtrl)), silent = !verbose))
                      }
                    }
                    if (inherits(res.ML, "try-error")) 
                      stop(mstyle$stop(paste0("Cannot fit ML model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))))
                    if (package == "lme4") {
                      if (is.na(ll.QE)) {
                        ll.ML <- c(logLik(res.ML))
                      }
                      else {
                        ll.ML <- ll.QE - 1/2 * deviance(res.ML)
                      }
                    }
                    else {
                      ll.ML <- c(logLik(res.ML))
                    }
                  }
                  if (is.element(method, c("FE", "EE", "CE"))) {
                    beta <- cbind(coef(res.FE)[seq_len(p)])
                    vb <- vcov(res.FE)[seq_len(p), seq_len(p), drop = FALSE]
                    tau2 <- 0
                    sigma2 <- NA
                    parms <- p + k
                    p.eff <- p + k
                    k.eff <- 2 * k
                  }
                  if (method == "ML") {
                    if (package == "lme4") {
                      beta <- cbind(lme4::fixef(res.ML)[seq_len(p)])
                      vb <- as.matrix(vcov(res.ML))[seq_len(p), seq_len(p), drop = FALSE]
                      tau2 <- lme4::VarCorr(res.ML)[[1]][1]
                    }
                    if (package == "GLMMadaptive") {
                      beta <- cbind(GLMMadaptive::fixef(res.ML)[seq_len(p)])
                      vb <- as.matrix(vcov(res.ML))[seq_len(p), seq_len(p), drop = FALSE]
                      tau2 <- res.ML$D[1, 1]
                    }
                    if (package == "glmmTMB") {
                      beta <- cbind(glmmTMB::fixef(res.ML)$cond[seq_len(p)])
                      vb <- as.matrix(vcov(res.ML)$cond)[seq_len(p), seq_len(p), drop = FALSE]
                      tau2 <- glmmTMB::VarCorr(res.ML)[[1]][[1]][[1]]
                    }
                    sigma2 <- NA
                    parms <- p + k + 1
                    p.eff <- p + k
                    k.eff <- 2 * k
                  }
                }
                if (model == "UM.RS") {
                  if (verbose) 
                    message(mstyle$message("Fitting FE model ..."))
                  if (package == "lme4") {
                    if (verbose) {
                      res.FE <- try(lme4::glmer(dat.grp ~ -1 + X.fit + const + (1 | study), offset = dat.off, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = do.call(lme4::glmerControl, glmerCtrl)), silent = !verbose)
                    }
                    else {
                      res.FE <- suppressMessages(try(lme4::glmer(dat.grp ~ -1 + X.fit + const + (1 | study), offset = dat.off, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = do.call(lme4::glmerControl, glmerCtrl)), silent = !verbose))
                    }
                  }
                  if (package == "GLMMadaptive") {
                    if (is.element(measure, c("OR", "RR", "RD"))) {
                      dat.mm <- data.frame(xi = dat.grp[, "xi"], mi = dat.grp[, "mi"], study = study, const = const)
                      res.FE <- try(GLMMadaptive::mixed_model(cbind(xi, mi) ~ -1 + X.fit + const, random = ~1 | study, data = dat.mm, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = glmerCtrl), silent = !verbose)
                    }
                    else {
                      dat.mm <- data.frame(xi = dat.grp, study = study, const = const)
                      res.FE <- try(GLMMadaptive::mixed_model(xi ~ -1 + X.fit + const + offset(dat.off), random = ~1 | study, data = dat.mm, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = glmerCtrl), silent = !verbose)
                    }
                  }
                  if (package == "glmmTMB") {
                    if (verbose) {
                      res.FE <- try(glmmTMB::glmmTMB(dat.grp ~ -1 + X.fit + const + (1 | study), offset = dat.off, family = dat.fam, verbose = verbose, data = NULL, control = do.call(glmmTMB::glmmTMBControl, glmerCtrl)), silent = !verbose)
                    }
                    else {
                      res.FE <- suppressMessages(try(glmmTMB::glmmTMB(dat.grp ~ -1 + X.fit + const + (1 | study), offset = dat.off, family = dat.fam, verbose = verbose, data = NULL, control = do.call(glmmTMB::glmmTMBControl, glmerCtrl)), silent = !verbose))
                    }
                  }
                  if (inherits(res.FE, "try-error")) 
                    stop(mstyle$stop(paste0("Cannot fit FE model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))))
                  ll.FE <- c(logLik(res.FE))
                  QEconv <- FALSE
                  ll.QE <- NA
                  if (!isTRUE(ddd$skiphet)) {
                    if (k > 1 && verbose) 
                      message(mstyle$message("Fitting saturated model ..."))
                    if (k > 1) {
                      X.QE <- model.matrix(~-1 + X.fit + const + study:group1)
                      res.QE <- try(glm(dat.grp ~ -1 + X.QE, offset = dat.off, family = dat.fam, control = glmCtrl), silent = TRUE)
                      X.QE <- X.QE[, !is.na(coef(res.QE)), drop = FALSE]
                      if (package == "lme4") {
                        if (verbose) {
                          res.QE <- try(lme4::glmer(dat.grp ~ -1 + X.QE + (1 | study), offset = dat.off, family = dat.fam, start = c(sqrt(lme4::VarCorr(res.FE)[[1]][1])), nAGQ = nAGQ, verbose = verbose, control = do.call(lme4::glmerControl, glmerCtrl)), silent = !verbose)
                        }
                        else {
                          res.QE <- suppressMessages(try(lme4::glmer(dat.grp ~ -1 + X.QE + (1 | study), offset = dat.off, family = dat.fam, start = c(sqrt(lme4::VarCorr(res.FE)[[1]][1])), nAGQ = nAGQ, verbose = verbose, control = do.call(lme4::glmerControl, glmerCtrl)), silent = !verbose))
                        }
                      }
                      if (package == "GLMMadaptive") {
                        glmerCtrl$max_coef_value <- 50
                        if (is.element(measure, c("OR", "RR", "RD"))) {
                          dat.mm <- data.frame(xi = dat.grp[, "xi"], mi = dat.grp[, "mi"], study = study)
                          res.QE <- try(GLMMadaptive::mixed_model(cbind(xi, mi) ~ -1 + X.QE, random = ~1 | study, data = dat.mm, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = glmerCtrl, initial_values = list(D = matrix(res.FE$D[1, 1]))), silent = !verbose)
                        }
                        else {
                          dat.mm <- data.frame(xi = dat.grp, study = study)
                          res.QE <- try(GLMMadaptive::mixed_model(xi ~ -1 + X.QE + offset(dat.off), random = ~1 | study, data = dat.mm, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = glmerCtrl), silent = !verbose)
                        }
                      }
                      if (package == "glmmTMB") {
                        if (verbose) {
                          res.QE <- try(glmmTMB::glmmTMB(dat.grp ~ -1 + X.QE + (1 | study), offset = dat.off, family = dat.fam, start = list(theta = sqrt(glmmTMB::VarCorr(res.FE)[[1]][[1]][[1]])), verbose = verbose, data = NULL, control = do.call(glmmTMB::glmmTMBControl, glmerCtrl)), silent = !verbose)
                        }
                        else {
                          res.QE <- suppressMessages(try(glmmTMB::glmmTMB(dat.grp ~ -1 + X.QE + (1 | study), offset = dat.off, family = dat.fam, start = list(theta = sqrt(glmmTMB::VarCorr(res.FE)[[1]][[1]][[1]])), verbose = verbose, data = NULL, control = do.call(glmmTMB::glmmTMBControl, glmerCtrl)), silent = !verbose))
                        }
                      }
                    }
                    else {
                      res.QE <- res.FE
                    }
                    if (inherits(res.QE, "try-error")) {
                      warning(mstyle$warning(paste0("Cannot fit saturated model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))), call. = FALSE)
                    }
                    else {
                      QEconv <- TRUE
                      ll.QE <- c(logLik(res.QE))
                      if (package == "lme4") {
                        b2.QE <- cbind(lme4::fixef(res.QE)[-seq_len(p + 1)])
                        vb2.QE <- as.matrix(vcov(res.QE))[-seq_len(p + 1), -seq_len(p + 1), drop = FALSE]
                      }
                      if (package == "GLMMadaptive") {
                        b2.QE <- cbind(GLMMadaptive::fixef(res.QE)[-seq_len(p + 1)])
                        vb2.QE <- as.matrix(vcov(res.QE))[-seq_len(p + 1), -seq_len(p + 1), drop = FALSE]
                        vb2.QE <- vb2.QE[-nrow(vb2.QE), -ncol(vb2.QE)]
                      }
                      if (package == "glmmTMB") {
                        b2.QE <- cbind(glmmTMB::fixef(res.QE)$cond[-seq_len(p + 1)])
                        vb2.QE <- as.matrix(vcov(res.QE)$cond)[-seq_len(p + 1), -seq_len(p + 1), drop = FALSE]
                      }
                    }
                  }
                  if (method == "ML") {
                    if (verbose) 
                      message(mstyle$message("Fitting ML model ..."))
                    if (package == "lme4") {
                      if (verbose) {
                        if (cor) {
                          res.ML <- try(lme4::glmer(dat.grp ~ -1 + X.fit + const + (group | study), offset = dat.off, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = do.call(lme4::glmerControl, glmerCtrl)), silent = !verbose)
                        }
                        else {
                          res.ML <- try(lme4::glmer(dat.grp ~ -1 + X.fit + const + (group || study), offset = dat.off, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = do.call(lme4::glmerControl, glmerCtrl)), silent = !verbose)
                        }
                      }
                      else {
                        if (cor) {
                          res.ML <- suppressMessages(try(lme4::glmer(dat.grp ~ -1 + X.fit + const + (group | study), offset = dat.off, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = do.call(lme4::glmerControl, glmerCtrl)), silent = !verbose))
                        }
                        else {
                          res.ML <- suppressMessages(try(lme4::glmer(dat.grp ~ -1 + X.fit + const + (group || study), offset = dat.off, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = do.call(lme4::glmerControl, glmerCtrl)), silent = !verbose))
                        }
                      }
                    }
                    if (package == "GLMMadaptive") {
                      if (is.element(measure, c("OR", "RR", "RD"))) {
                        dat.mm <- data.frame(xi = dat.grp[, "xi"], mi = dat.grp[, "mi"], study = study, const = const, group = group)
                        if (cor) {
                          res.ML <- try(GLMMadaptive::mixed_model(cbind(xi, mi) ~ -1 + X.fit + const, random = ~group | study, data = dat.mm, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = glmerCtrl), silent = !verbose)
                        }
                        else {
                          res.ML <- try(GLMMadaptive::mixed_model(cbind(xi, mi) ~ -1 + X.fit + const, random = ~group || study, data = dat.mm, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = glmerCtrl), silent = !verbose)
                        }
                      }
                      else {
                        dat.mm <- data.frame(xi = dat.grp, study = study, const = const, group = group)
                        if (cor) {
                          res.ML <- try(GLMMadaptive::mixed_model(xi ~ -1 + X.fit + const + offset(dat.off), random = ~group | study, data = dat.mm, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = glmerCtrl), silent = !verbose)
                        }
                        else {
                          res.ML <- try(GLMMadaptive::mixed_model(xi ~ -1 + X.fit + const + offset(dat.off), random = ~group || study, data = dat.mm, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = glmerCtrl), silent = !verbose)
                        }
                      }
                    }
                    if (package == "glmmTMB") {
                      if (verbose) {
                        if (cor) {
                          res.ML <- try(glmmTMB::glmmTMB(dat.grp ~ -1 + X.fit + const + (group | study), offset = dat.off, family = dat.fam, verbose = verbose, data = NULL, control = do.call(glmmTMB::glmmTMBControl, glmerCtrl)), silent = !verbose)
                        }
                        else {
                          res.ML <- try(glmmTMB::glmmTMB(dat.grp ~ -1 + X.fit + const + (1 | study) + (group - 1 | study), offset = dat.off, family = dat.fam, verbose = verbose, data = NULL, control = do.call(glmmTMB::glmmTMBControl, glmerCtrl)), silent = !verbose)
                        }
                      }
                      else {
                        if (cor) {
                          res.ML <- suppressMessages(try(glmmTMB::glmmTMB(dat.grp ~ -1 + X.fit + const + (group | study), offset = dat.off, family = dat.fam, verbose = verbose, data = NULL, control = do.call(glmmTMB::glmmTMBControl, glmerCtrl)), silent = !verbose))
                        }
                        else {
                          res.ML <- suppressMessages(try(glmmTMB::glmmTMB(dat.grp ~ -1 + X.fit + const + (1 | study) + (group - 1 | study), offset = dat.off, family = dat.fam, verbose = verbose, data = NULL, control = do.call(glmmTMB::glmmTMBControl, glmerCtrl)), silent = !verbose))
                        }
                      }
                    }
                    if (inherits(res.ML, "try-error")) 
                      stop(mstyle$stop(paste0("Cannot fit ML model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))))
                    ll.ML <- c(logLik(res.ML))
                  }
                  if (is.element(method, c("FE", "EE", "CE"))) {
                    tau2 <- 0
                    if (package == "lme4") {
                      beta <- cbind(lme4::fixef(res.FE)[seq_len(p)])
                      vb <- as.matrix(vcov(res.FE))[seq_len(p), seq_len(p), drop = FALSE]
                      sigma2 <- lme4::VarCorr(res.FE)[[1]][1]
                    }
                    if (package == "GLMMadaptive") {
                      beta <- cbind(GLMMadaptive::fixef(res.FE)[seq_len(p)])
                      vb <- as.matrix(vcov(res.FE))[seq_len(p), seq_len(p), drop = FALSE]
                      sigma2 <- res.FE$D[1, 1]
                    }
                    if (package == "glmmTMB") {
                      beta <- cbind(glmmTMB::fixef(res.FE)$cond[seq_len(p)])
                      vb <- as.matrix(vcov(res.FE)$cond)[seq_len(p), seq_len(p), drop = FALSE]
                      sigma2 <- glmmTMB::VarCorr(res.FE)[[1]][[1]][[1]]
                    }
                    parms <- p + 1 + 1
                    p.eff <- p + 1
                    k.eff <- 2 * k
                  }
                  if (method == "ML") {
                    if (package == "lme4") {
                      beta <- cbind(lme4::fixef(res.ML)[seq_len(p)])
                      vb <- as.matrix(vcov(res.ML))[seq_len(p), seq_len(p), drop = FALSE]
                      if (cor) {
                        tau2 <- lme4::VarCorr(res.ML)[[1]][2, 2]
                        sigma2 <- lme4::VarCorr(res.ML)[[1]][1, 1]
                        rho <- lme4::VarCorr(res.ML)[[1]][1, 2]/sqrt(tau2 * sigma2)
                      }
                      else {
                        tau2 <- lme4::VarCorr(res.ML)[[2]][1]
                        sigma2 <- lme4::VarCorr(res.ML)[[1]][1]
                      }
                    }
                    if (package == "GLMMadaptive") {
                      beta <- cbind(GLMMadaptive::fixef(res.ML)[seq_len(p)])
                      vb <- as.matrix(vcov(res.ML))[seq_len(p), seq_len(p), drop = FALSE]
                      tau2 <- res.ML$D[2, 2]
                      sigma2 <- res.ML$D[1, 1]
                      if (cor) 
                        rho <- res.ML$D[1, 2]/sqrt(tau2 * sigma2)
                    }
                    if (package == "glmmTMB") {
                      beta <- cbind(glmmTMB::fixef(res.ML)$cond[seq_len(p)])
                      vb <- as.matrix(vcov(res.ML)$cond)[seq_len(p), seq_len(p), drop = FALSE]
                      if (cor) {
                        tau2 <- glmmTMB::VarCorr(res.ML)[[1]][[1]][2, 2]
                        sigma2 <- glmmTMB::VarCorr(res.ML)[[1]][[1]][1, 1]
                        rho <- glmmTMB::VarCorr(res.ML)[[1]][[1]][1, 2]/sqrt(tau2 * sigma2)
                      }
                      else {
                        tau2 <- glmmTMB::VarCorr(res.ML)[[1]][[2]][[1]]
                        sigma2 <- glmmTMB::VarCorr(res.ML)[[1]][[1]][[1]]
                      }
                    }
                    parms <- p + 1 + 2
                    p.eff <- p + 1
                    k.eff <- 2 * k
                  }
                }
            }
            if ((measure == "IRR" && model == "CM.EL") || (measure == "OR" && model == "CM.AL") || (measure == "OR" && model == "CM.EL")) {
                if (measure == "OR") {
                  dat.grp <- cbind(xi = ai, mi = ci)
                  dat.off <- log((ai + bi)/(ci + di))
                }
                if (measure == "IRR") {
                  dat.grp <- cbind(xi = x1i, mi = x2i)
                  dat.off <- log(t1i/t2i)
                }
                study <- factor(seq_len(k))
                X.fit <- X
                if (.isTRUE(ddd$retdat)) 
                  return(list(dat.grp = dat.grp, X.fit = X.fit, study = study, dat.off = if (!is.null(dat.off)) dat.off else NULL))
                if (verbose) 
                  message(mstyle$message("Fitting FE model ..."))
                res.FE <- try(glm(dat.grp ~ -1 + X.fit, offset = dat.off, family = binomial, control = glmCtrl), silent = !verbose)
                if (inherits(res.FE, "try-error")) 
                  stop(mstyle$stop(paste0("Cannot fit FE model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))))
                ll.FE <- c(logLik(res.FE))
                QEconv <- FALSE
                ll.QE <- NA
                if (!isTRUE(ddd$skiphet)) {
                  if (k > 1 && verbose) 
                    message(mstyle$message("Fitting saturated model ..."))
                  if (k > 1) {
                    X.QE <- model.matrix(~-1 + X.fit + study)
                    res.QE <- try(glm(dat.grp ~ -1 + X.QE, offset = dat.off, family = binomial, control = glmCtrl), silent = !verbose)
                  }
                  else {
                    res.QE <- res.FE
                  }
                  if (inherits(res.QE, "try-error")) {
                    warning(mstyle$warning(paste0("Cannot fit saturated model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))), call. = FALSE)
                  }
                  else {
                    QEconv <- TRUE
                    ll.QE <- c(logLik(res.QE))
                    b2.QE <- cbind(coef(res.QE, complete = FALSE)[-seq_len(p)])
                    vb2.QE <- vcov(res.QE, complete = FALSE)[-seq_len(p), -seq_len(p), drop = FALSE]
                  }
                }
                if (method == "ML") {
                  if (verbose) 
                    message(mstyle$message("Fitting ML model ..."))
                  if (package == "lme4") {
                    if (verbose) {
                      res.ML <- try(lme4::glmer(dat.grp ~ -1 + X.fit + (1 | study), offset = dat.off, family = binomial, nAGQ = nAGQ, verbose = verbose, control = do.call(lme4::glmerControl, glmerCtrl)), silent = !verbose)
                    }
                    else {
                      res.ML <- suppressMessages(try(lme4::glmer(dat.grp ~ -1 + X.fit + (1 | study), offset = dat.off, family = binomial, nAGQ = nAGQ, verbose = verbose, control = do.call(lme4::glmerControl, glmerCtrl)), silent = !verbose))
                    }
                  }
                  if (package == "GLMMadaptive") {
                    dat.mm <- data.frame(xi = dat.grp[, "xi"], mi = dat.grp[, "mi"], study = study)
                    res.ML <- try(GLMMadaptive::mixed_model(cbind(xi, mi) ~ -1 + X.fit + offset(dat.off), random = ~1 | study, data = dat.mm, family = binomial, nAGQ = nAGQ, verbose = verbose, control = glmerCtrl), silent = !verbose)
                  }
                  if (package == "glmmTMB") {
                    if (verbose) {
                      res.ML <- try(glmmTMB::glmmTMB(dat.grp ~ -1 + X.fit + (1 | study), offset = dat.off, family = binomial, verbose = verbose, data = NULL, control = do.call(glmmTMB::glmmTMBControl, glmerCtrl)), silent = !verbose)
                    }
                    else {
                      res.ML <- suppressMessages(try(glmmTMB::glmmTMB(dat.grp ~ -1 + X.fit + (1 | study), offset = dat.off, family = binomial, verbose = verbose, data = NULL, control = do.call(glmmTMB::glmmTMBControl, glmerCtrl)), silent = !verbose))
                    }
                  }
                  if (inherits(res.ML, "try-error")) 
                    stop(mstyle$stop(paste0("Cannot fit ML model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))))
                  if (package == "lme4") {
                    if (is.na(ll.QE)) {
                      ll.ML <- c(logLik(res.ML))
                    }
                    else {
                      if (verbose) {
                        ll.ML <- ll.QE - 1/2 * deviance(res.ML)
                      }
                      else {
                        ll.ML <- ll.QE - 1/2 * suppressWarnings(deviance(res.ML))
                      }
                    }
                  }
                  else {
                    ll.ML <- c(logLik(res.ML))
                  }
                }
                if (is.element(method, c("FE", "EE", "CE"))) {
                  beta <- cbind(coef(res.FE)[seq_len(p)])
                  vb <- vcov(res.FE)[seq_len(p), seq_len(p), drop = FALSE]
                  tau2 <- 0
                  sigma2 <- NA
                  parms <- p
                  p.eff <- p
                  k.eff <- k
                }
                if (method == "ML") {
                  if (package == "lme4") {
                    beta <- cbind(lme4::fixef(res.ML)[seq_len(p)])
                    vb <- as.matrix(vcov(res.ML))[seq_len(p), seq_len(p), drop = FALSE]
                    tau2 <- lme4::VarCorr(res.ML)[[1]][1]
                  }
                  if (package == "GLMMadaptive") {
                    beta <- cbind(GLMMadaptive::fixef(res.ML)[seq_len(p)])
                    vb <- as.matrix(vcov(res.ML))[seq_len(p), seq_len(p), drop = FALSE]
                    tau2 <- res.ML$D[1, 1]
                  }
                  if (package == "glmmTMB") {
                    beta <- cbind(glmmTMB::fixef(res.ML)$cond[seq_len(p)])
                    vb <- as.matrix(vcov(res.ML)$cond)[seq_len(p), seq_len(p), drop = FALSE]
                    tau2 <- glmmTMB::VarCorr(res.ML)[[1]][[1]][[1]]
                  }
                  sigma2 <- NA
                  parms <- p + 1
                  p.eff <- p
                  k.eff <- k
                }
            }
            if (measure == "OR" && model == "CM.EL") {
                if (verbose) 
                  message(mstyle$message("Fitting FE model ..."))
                if (is.element(optimizer, c("optim", "nlminb", "uobyqa", "newuoa", "bobyqa", "nloptr", "nlm", "hjk", "nmk", "mads", "ucminf", "lbfgsb3c", "subplex", "BBoptim", "optimParallel", "Rcgmin", "Rvmmin"))) {
                  if (optimizer == "optim") {
                    par.arg <- "par"
                    ctrl.arg <- ", control=optCtrl"
                  }
                  if (optimizer == "nlminb") {
                    par.arg <- "start"
                    ctrl.arg <- ", control=optCtrl"
                  }
                  if (is.element(optimizer, c("uobyqa", "newuoa", "bobyqa"))) {
                    par.arg <- "par"
                    optimizer <- paste0("minqa::", optimizer)
                    ctrl.arg <- ", control=optCtrl"
                  }
                  if (optimizer == "nloptr") {
                    par.arg <- "x0"
                    optimizer <- paste0("nloptr::nloptr")
                    ctrl.arg <- ", opts=optCtrl"
                  }
                  if (optimizer == "nlm") {
                    par.arg <- "p"
                    ctrl.arg <- paste(names(optCtrl), unlist(optCtrl), sep = "=", collapse = ", ")
                    if (nchar(ctrl.arg) != 0) 
                      ctrl.arg <- paste0(", ", ctrl.arg)
                  }
                  if (is.element(optimizer, c("hjk", "nmk", "mads"))) {
                    par.arg <- "par"
                    optimizer <- paste0("dfoptim::", optimizer)
                    ctrl.arg <- ", control=optCtrl"
                  }
                  if (is.element(optimizer, c("ucminf", "lbfgsb3c", "subplex"))) {
                    par.arg <- "par"
                    optimizer <- paste0(optimizer, "::", optimizer)
                    ctrl.arg <- ", control=optCtrl"
                  }
                  if (optimizer == "BBoptim") {
                    par.arg <- "par"
                    optimizer <- "BB::BBoptim"
                    ctrl.arg <- ", quiet=TRUE, control=optCtrl"
                  }
                  if (optimizer == "Rcgmin") {
                    par.arg <- "par"
                    optimizer <- "Rcgmin::Rcgmin"
                    ctrl.arg <- ", control=optCtrl"
                  }
                  if (optimizer == "Rvmmin") {
                    par.arg <- "par"
                    optimizer <- "Rvmmin::Rvmmin"
                    ctrl.arg <- ", control=optCtrl"
                  }
                  if (optimizer == "optimParallel") {
                    par.arg <- "par"
                    optimizer <- paste0("optimParallel::optimParallel")
                    ctrl.arg <- ", control=optCtrl, parallel=parallel"
                    parallel$cl <- NULL
                    if (is.null(cl)) {
                      ncpus <- as.integer(ncpus)
                      if (ncpus < 1) 
                        stop(mstyle$stop("Control argument 'ncpus' must be >= 1."))
                      cl <- parallel::makePSOCKcluster(ncpus)
                      on.exit(parallel::stopCluster(cl), add = TRUE)
                    }
                    else {
                      if (!inherits(cl, "SOCKcluster")) 
                        stop(mstyle$stop("Specified cluster is not of class 'SOCKcluster'."))
                    }
                    parallel$cl <- cl
                    if (is.null(parallel$forward)) 
                      parallel$forward <- FALSE
                    if (is.null(parallel$loginfo)) {
                      if (verbose) {
                        parallel$loginfo <- TRUE
                      }
                      else {
                        parallel$loginfo <- FALSE
                      }
                    }
                  }
                  optcall <- paste(optimizer, "(", par.arg, "=c(coef(res.FE)[seq_len(p)], 0),\n               .dnchg, ", ifelse(optimizer == "optim", "method=optmethod, ", ""), "ai=ai, bi=bi, ci=ci, di=di, X.fit=X.fit, random=FALSE,\n               verbose=verbose, digits=digits,\n               dnchgcalc=con$dnchgcalc, dnchgprec=con$dnchgprec, intCtrl=intCtrl", ctrl.arg, ")\n", sep = "")
                  if (verbose) {
                    res.FE <- try(eval(str2lang(optcall)), silent = !verbose)
                  }
                  else {
                    res.FE <- try(suppressWarnings(eval(str2lang(optcall))), silent = !verbose)
                  }
                  if (optimizer == "optimParallel::optimParallel" && verbose) {
                    tmp <- capture.output(print(res.FE$loginfo))
                    .print.output(tmp, mstyle$verbose)
                  }
                  if (inherits(res.FE, "try-error")) 
                    stop(mstyle$stop(paste0("Cannot fit FE model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))))
                  if (is.element(optimizer, c("optim", "nlminb", "dfoptim::hjk", "dfoptim::nmk", "lbfgsb3c::lbfgsb3c", "subplex::subplex", "BB::BBoptim", "Rcgmin::Rcgmin", "Rvmmin:Rvmmin", "optimParallel::optimParallel")) && res.FE$convergence != 0) 
                    stop(mstyle$stop(paste0("Cannot fit FE model. Optimizer (", optimizer, ") did not achieve convergence (convergence = ", res.FE$convergence, ").")))
                  if (is.element(optimizer, c("dfoptim::mads")) && res.FE$convergence > optCtrl$tol) 
                    stop(mstyle$stop(paste0("Cannot fit FE model. Optimizer (", optimizer, ") did not achieve convergence (convergence = ", res.FE$convergence, ").")))
                  if (is.element(optimizer, c("minqa::uobyqa", "minqa::newuoa", "minqa::bobyqa")) && res.FE$ierr != 0) 
                    stop(mstyle$stop(paste0("Cannot fit FE model. Optimizer (", optimizer, ") did not achieve convergence (ierr = ", res.FE$ierr, ").")))
                  if (optimizer == "nloptr::nloptr" && !(res.FE$status >= 1 && res.FE$status <= 4)) 
                    stop(mstyle$stop(paste0("Cannot fit FE model. Optimizer (", optimizer, ") did not achieve convergence (status = ", res.FE$status, ").")))
                  if (optimizer == "ucminf::ucminf" && !(res.FE$convergence == 1 || res.FE$convergence == 2)) 
                    stop(mstyle$stop(paste0("Cannot fit FE model. Optimizer (", optimizer, ") did not achieve convergence (convergence = ", res.FE$convergence, ").")))
                  if (verbose > 2) {
                    cat("\n")
                    tmp <- capture.output(print(res.FE))
                    .print.output(tmp, mstyle$verbose)
                  }
                  if (optimizer == "nloptr::nloptr") 
                    res.FE$par <- res.FE$solution
                  if (optimizer == "nlm") 
                    res.FE$par <- res.FE$estimate
                  if (verbose > 1) 
                    message(mstyle$message("Computing Hessian ..."))
                  if (con$hesspack == "numDeriv") 
                    h.FE <- numDeriv::hessian(.dnchg, x = res.FE$par, method.args = hessianCtrl, ai = ai, bi = bi, ci = ci, di = di, X.fit = X.fit, random = FALSE, verbose = verbose, digits = digits, dnchgcalc = con$dnchgcalc, dnchgprec = con$dnchgprec)
                  if (con$hesspack == "pracma") 
                    h.FE <- pracma::hessian(.dnchg, x0 = res.FE$par, ai = ai, bi = bi, ci = ci, di = di, X.fit = X.fit, random = FALSE, verbose = verbose, digits = digits, dnchgcalc = con$dnchgcalc, dnchgprec = con$dnchgprec)
                  if (is.element(optimizer, c("optim", "dfoptim::hjk", "dfoptim::nmk", "dfoptim::mads", "ucminf::ucminf", "lbfgsb3c::lbfgsb3c", "subplex::subplex", "BB::BBoptim", "Rcgmin::Rcgmin", "Rvmmin:Rvmmin", "optimParallel::optimParallel"))) 
                    ll.FE <- -1 * res.FE$value
                  if (is.element(optimizer, c("nlminb", "nloptr::nloptr"))) 
                    ll.FE <- -1 * res.FE$objective
                  if (is.element(optimizer, c("minqa::uobyqa", "minqa::newuoa", "minqa::bobyqa"))) 
                    ll.FE <- -1 * res.FE$fval
                  if (optimizer == "nlm") 
                    ll.FE <- -1 * res.FE$minimum
                  if (QEconv) {
                    if (k > 1 && verbose) 
                      message(mstyle$message("Fitting saturated model ..."))
                    if (k > 1) {
                      b.QE <- coef(res.QE, complete = TRUE)
                      is.aliased <- is.na(b.QE)
                      b.QE <- b.QE[!is.aliased]
                      X.QE <- X.QE[, !is.aliased, drop = FALSE]
                      optcall <- paste(optimizer, "(", par.arg, "=c(b.QE, 0),\n                     .dnchg, ", ifelse(optimizer == "optim", "method=optmethod, ", ""), "ai=ai, bi=bi, ci=ci, di=di, X.fit=X.QE, random=FALSE,\n                     verbose=verbose, digits=digits,\n                     dnchgcalc=con$dnchgcalc, dnchgprec=con$dnchgprec, intCtrl=intCtrl", ctrl.arg, ")\n", sep = "")
                      if (verbose) {
                        res.QE <- try(eval(str2lang(optcall)), silent = !verbose)
                      }
                      else {
                        res.QE <- try(suppressWarnings(eval(str2lang(optcall))), silent = !verbose)
                      }
                      if (optimizer == "optimParallel::optimParallel" && verbose) {
                        tmp <- capture.output(print(res.QE$loginfo))
                        .print.output(tmp, mstyle$verbose)
                      }
                      if (inherits(res.QE, "try-error")) {
                        warning(mstyle$warning(paste0("Cannot fit saturated model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))), call. = FALSE)
                        QEconv <- FALSE
                        ll.QE <- NA
                      }
                      if (QEconv && is.element(optimizer, c("optim", "nlminb", "dfoptim::hjk", "dfoptim::nmk", "lbfgsb3c::lbfgsb3c", "subplex::subplex", "BB::BBoptim", "Rcgmin::Rcgmin", "Rvmmin:Rvmmin", "optimParallel::optimParallel")) && res.QE$convergence != 0) {
                        warning(mstyle$warning(paste0("Cannot fit saturated model. Optimizer (", optimizer, ") did not achieve convergence (convergence = ", res.QE$convergence, ").")), call. = FALSE)
                        QEconv <- FALSE
                        ll.QE <- NA
                      }
                      if (QEconv && is.element(optimizer, c("dfoptim::mads")) && res.QE$convergence > optCtrl$tol) {
                        warning(mstyle$warning(paste0("Cannot fit saturated model. Optimizer (", optimizer, ") did not achieve convergence (convergence = ", res.QE$convergence, ").")), call. = FALSE)
                        QEconv <- FALSE
                        ll.QE <- NA
                      }
                      if (QEconv && is.element(optimizer, c("minqa::uobyqa", "minqa::newuoa", "minqa::bobyqa")) && res.QE$ierr != 0) {
                        warning(mstyle$warning(paste0("Cannot fit saturated model. Optimizer (", optimizer, ") did not achieve convergence (ierr = ", res.QE$ierr, ").")), call. = FALSE)
                        QEconv <- FALSE
                        ll.QE <- NA
                      }
                      if (QEconv && optimizer == "nloptr::nloptr" && !(res.QE$status >= 1 && res.QE$status <= 4)) {
                        warning(mstyle$warning(paste0("Cannot fit saturated model. Optimizer (", optimizer, ") did not achieve convergence (status = ", res.QE$status, ").")), call. = FALSE)
                        QEconv <- FALSE
                        ll.QE <- NA
                      }
                      if (QEconv && optimizer == "ucminf::ucminf" && !(res.QE$convergence == 1 || res.QE$convergence == 2)) {
                        warning(mstyle$warning(paste0("Cannot fit saturated model. Optimizer (", optimizer, ") did not achieve convergence (convergence = ", res.QE$convergence, ").")), call. = FALSE)
                        QEconv <- FALSE
                        ll.QE <- NA
                      }
                      if (verbose > 2) {
                        cat("\n")
                        tmp <- capture.output(print(res.QE))
                        .print.output(tmp, mstyle$verbose)
                      }
                      if (QEconv && optimizer == "nloptr::nloptr") 
                        res.QE$par <- res.QE$solution
                      if (QEconv && optimizer == "nlm") 
                        res.QE$par <- res.QE$estimate
                      if (QEconv) {
                        if (verbose > 1) 
                          message(mstyle$message("Computing Hessian ..."))
                        if (con$hesspack == "numDeriv") 
                          h.QE <- numDeriv::hessian(.dnchg, x = res.QE$par, method.args = hessianCtrl, ai = ai, bi = bi, ci = ci, di = di, X.fit = X.QE, random = FALSE, verbose = verbose, digits = digits, dnchgcalc = con$dnchgcalc, dnchgprec = con$dnchgprec)
                        if (con$hesspack == "pracma") 
                          h.QE <- pracma::hessian(.dnchg, x0 = res.QE$par, ai = ai, bi = bi, ci = ci, di = di, X.fit = X.QE, random = FALSE, verbose = verbose, digits = digits, dnchgcalc = con$dnchgcalc, dnchgprec = con$dnchgprec)
                      }
                    }
                    else {
                      res.QE <- res.FE
                      h.QE <- h.FE
                    }
                  }
                  if (k > 1 && QEconv) {
                    if (is.element(optimizer, c("optim", "dfoptim::hjk", "dfoptim::nmk", "dfoptim::mads", "ucminf::ucminf", "lbfgsb3c::lbfgsb3c", "subplex::subplex", "BB::BBoptim", "Rcgmin::Rcgmin", "Rvmmin:Rvmmin", "optimParallel::optimParallel"))) 
                      ll.QE <- -1 * res.QE$value
                    if (is.element(optimizer, c("nlminb", "nloptr::nloptr"))) 
                      ll.QE <- -1 * res.QE$objective
                    if (is.element(optimizer, c("minqa::uobyqa", "minqa::newuoa", "minqa::bobyqa"))) 
                      ll.QE <- -1 * res.QE$fval
                    if (optimizer == "nlm") 
                      ll.QE <- -1 * res.QE$minimum
                    b2.QE <- res.QE$par
                    hessian <- h.QE
                    p.QE <- length(b2.QE)
                    b2.QE <- b2.QE[-p.QE]
                    hessian <- hessian[-p.QE, -p.QE, drop = FALSE]
                    p.QE <- length(b2.QE)
                    is.0 <- colSums(hessian == 0) == p.QE
                    b2.QE <- b2.QE[!is.0]
                    hessian <- hessian[!is.0, !is.0, drop = FALSE]
                    b2.QE <- cbind(b2.QE[-seq_len(p)])
                    h.A <- hessian[seq_len(p), seq_len(p), drop = FALSE]
                    h.B <- hessian[seq_len(p), -seq_len(p), drop = FALSE]
                    h.C <- hessian[-seq_len(p), seq_len(p), drop = FALSE]
                    h.D <- hessian[-seq_len(p), -seq_len(p), drop = FALSE]
                    chol.h.A <- try(chol(h.A), silent = !verbose)
                    if (inherits(chol.h.A, "try-error") || anyNA(chol.h.A)) {
                      warning(mstyle$warning("Cannot invert Hessian for saturated model."), call. = FALSE)
                      QE.Wld <- NA
                    }
                    else {
                      Ivb2.QE <- h.D - h.C %*% chol2inv(chol.h.A) %*% h.B
                      QE.Wld <- c(t(b2.QE) %*% Ivb2.QE %*% b2.QE)
                    }
                  }
                }
                if (is.element(optimizer, c("clogit", "clogistic"))) {
                  event <- unlist(lapply(seq_len(k), function(i) c(rep.int(1, ai[i]), rep.int(0, bi[i]), rep.int(1, ci[i]), rep.int(0, di[i]))))
                  group1 <- unlist(lapply(seq_len(k), function(i) c(rep.int(1, ai[i]), rep.int(1, bi[i]), rep.int(0, ci[i]), rep.int(0, di[i]))))
                  study.l <- factor(rep(seq_len(k), times = ni))
                  X.fit.l <- X[rep(seq_len(k), times = ni), , drop = FALSE]
                  X.fit.l <- cbind(group1 * X.fit.l)
                  const <- rep(1, length(event))
                  if (.isTRUE(ddd$retdat)) 
                    return(data.frame(event, group1, study.l, X.fit.l, const))
                  if (k > 1) {
                    if (optimizer == "clogit") {
                      args.clogit <- clogitCtrl
                      args.clogit$formula <- event ~ X.fit.l + strata(study.l)
                      res.FE <- try(do.call(clogit, args.clogit), silent = !verbose)
                    }
                    if (optimizer == "clogistic") {
                      args.clogistic <- clogisticCtrl
                      args.clogistic$formula <- event ~ X.fit.l
                      args.clogistic$strata <- study.l
                      res.FE <- try(do.call(Epi::clogistic, args.clogistic), silent = !verbose)
                    }
                  }
                  else {
                    stop(mstyle$stop(paste0("Cannot use '", optimizer, "' optimizer when k=1.")))
                  }
                  if (inherits(res.FE, "try-error")) 
                    stop(mstyle$stop(paste0("Cannot fit FE model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))))
                  if (QEconv) {
                    if (verbose) 
                      message(mstyle$message("Fitting saturated model ..."))
                    b.QE <- coef(res.QE, complete = TRUE)
                    is.aliased <- is.na(b.QE)
                    X.QE.l <- model.matrix(~-1 + X.fit.l + study.l:group1)
                    X.QE.l <- X.QE.l[, !is.aliased, drop = FALSE]
                    X.QE <- X.QE[, !is.aliased, drop = FALSE]
                    if (optimizer == "clogit") {
                      args.clogit <- clogitCtrl
                      args.clogit$formula <- event ~ X.QE.l + strata(study.l)
                      if (verbose) {
                        res.QE <- try(do.call(clogit, args.clogit), silent = !verbose)
                      }
                      else {
                        res.QE <- try(suppressWarnings(do.call(clogit, args.clogit)), silent = !verbose)
                      }
                    }
                    if (optimizer == "clogistic") {
                      args.clogistic <- clogisticCtrl
                      args.clogistic$formula <- event ~ X.QE.l
                      args.clogistic$strata <- study.l
                      res.QE <- try(do.call(Epi::clogistic, args.clogistic), silent = !verbose)
                    }
                    if (inherits(res.QE, "try-error")) 
                      stop(mstyle$stop(paste0("Cannot fit saturated model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))))
                    ll.FE <- -1 * .dnchg(c(cbind(coef(res.FE)), 0), ai = ai, bi = bi, ci = ci, di = di, X.fit = X.fit, random = FALSE, verbose = verbose, digits = digits, dnchgcalc = con$dnchgcalc, dnchgprec = con$dnchgprec)
                    ll.QE <- -1 * .dnchg(c(cbind(coef(res.QE)), 0), ai = ai, bi = bi, ci = ci, di = di, X.fit = X.QE, random = FALSE, verbose = verbose, digits = digits, dnchgcalc = con$dnchgcalc, dnchgprec = con$dnchgprec)
                    b2.QE <- cbind(coef(res.QE)[-seq_len(p)])
                    vb2.QE <- vcov(res.QE)[-seq_len(p), -seq_len(p), drop = FALSE]
                  }
                }
                if (method == "ML") {
                  if (verbose) 
                    message(mstyle$message("Fitting ML model ..."))
                  optcall <- paste(optimizer, "(", par.arg, "=c(beta, log(tau2+.01)),\n               .dnchg, ", ifelse(optimizer == "optim", "method=optmethod, ", ""), "ai=ai, bi=bi, ci=ci, di=di, X.fit=X.fit, random=TRUE,\n               verbose=verbose, digits=digits,\n               dnchgcalc=con$dnchgcalc, dnchgprec=con$dnchgprec, intCtrl=intCtrl", ctrl.arg, ")\n", sep = "")
                  if (verbose) {
                    res.ML <- try(eval(str2lang(optcall)), silent = !verbose)
                  }
                  else {
                    res.ML <- try(suppressWarnings(eval(str2lang(optcall))), silent = !verbose)
                  }
                  if (optimizer == "optimParallel::optimParallel" && verbose) {
                    tmp <- capture.output(print(res.ML$loginfo))
                    .print.output(tmp, mstyle$verbose)
                  }
                  if (inherits(res.ML, "try-error")) 
                    stop(mstyle$stop(paste0("Cannot fit ML model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))))
                  if (is.element(optimizer, c("optim", "nlminb", "dfoptim::hjk", "dfoptim::nmk", "lbfgsb3c::lbfgsb3c", "subplex::subplex", "BB::BBoptim", "Rcgmin::Rcgmin", "Rvmmin:Rvmmin", "optimParallel::optimParallel")) && res.ML$convergence != 0) 
                    stop(mstyle$stop(paste0("Cannot fit ML model. Optimizer (", optimizer, ") did not achieve convergence (convergence = ", res.ML$convergence, ").")))
                  if (is.element(optimizer, c("dfoptim::mads")) && res.ML$convergence > optCtrl$tol) 
                    stop(mstyle$stop(paste0("Cannot fit ML model. Optimizer (", optimizer, ") did not achieve convergence (convergence = ", res.ML$convergence, ").")))
                  if (is.element(optimizer, c("minqa::uobyqa", "minqa::newuoa", "minqa::bobyqa")) && res.ML$ierr != 0) 
                    stop(mstyle$stop(paste0("Cannot fit ML model. Optimizer (", optimizer, ") did not achieve convergence (ierr = ", res.ML$ierr, ").")))
                  if (optimizer == "nloptr::nloptr" && !(res.ML$status >= 1 && res.ML$status <= 4)) 
                    stop(mstyle$stop(paste0("Cannot fit ML model. Optimizer (", optimizer, ") did not achieve convergence (status = ", res.ML$status, ").")))
                  if (optimizer == "ucminf::ucminf" && !(res.ML$convergence == 1 || res.ML$convergence == 2)) 
                    stop(mstyle$stop(paste0("Cannot fit ML model. Optimizer (", optimizer, ") did not achieve convergence (convergence = ", res.ML$convergence, ").")))
                  if (verbose > 2) {
                    cat("\n")
                    tmp <- capture.output(print(res.ML))
                    .print.output(tmp, mstyle$verbose)
                  }
                  if (optimizer == "nloptr::nloptr") 
                    res.ML$par <- res.ML$solution
                  if (optimizer == "nlm") 
                    res.ML$par <- res.ML$estimate
                  if (verbose > 1) 
                    message(mstyle$message("Computing Hessian ..."))
                  tau2eff0 <- exp(res.ML$par[p + 1]) < con$tau2tol
                  if (tau2eff0) 
                    method <- "T0"
                  if (con$hesspack == "numDeriv") 
                    h.ML <- numDeriv::hessian(.dnchg, x = res.ML$par, method.args = hessianCtrl, ai = ai, bi = bi, ci = ci, di = di, X.fit = X.fit, random = !tau2eff0, verbose = verbose, digits = digits, dnchgcalc = con$dnchgcalc, dnchgprec = con$dnchgprec, intCtrl = intCtrl)
                  if (con$hesspack == "pracma") 
                    h.ML <- pracma::hessian(.dnchg, x0 = res.ML$par, ai = ai, bi = bi, ci = ci, di = di, X.fit = X.fit, random = !tau2eff0, verbose = verbose, digits = digits, dnchgcalc = con$dnchgcalc, dnchgprec = con$dnchgprec, intCtrl = intCtrl)
                  if (is.element(optimizer, c("optim", "dfoptim::hjk", "dfoptim::nmk", "dfoptim::mads", "ucminf::ucminf", "lbfgsb3c::lbfgsb3c", "subplex::subplex", "BB::BBoptim", "Rcgmin::Rcgmin", "Rvmmin:Rvmmin", "optimParallel::optimParallel"))) 
                    ll.ML <- -1 * res.ML$value
                  if (is.element(optimizer, c("nlminb", "nloptr::nloptr"))) 
                    ll.ML <- -1 * res.ML$objective
                  if (is.element(optimizer, c("minqa::uobyqa", "minqa::newuoa", "minqa::bobyqa"))) 
                    ll.ML <- -1 * res.ML$fval
                  if (optimizer == "nlm") 
                    ll.ML <- -1 * res.ML$minimum
                }
                if (is.element(method, c("FE", "EE", "CE", "T0"))) {
                  if (!is.element(optimizer, c("clogit", "clogistic"))) {
                    beta <- cbind(res.FE$par[seq_len(p)])
                    chol.h <- try(chol(h.FE[seq_len(p), seq_len(p)]), silent = !verbose)
                    if (inherits(chol.h, "try-error") || anyNA(chol.h)) {
                      if (anyNA(chol.h)) 
                        stop(mstyle$stop(paste0("Cannot invert Hessian for the ", ifelse(method == "T0", "ML", method), " model.")))
                      warning(mstyle$warning("Choleski factorization of Hessian failed. Trying inversion via QR decomposition."), call. = FALSE)
                      vb <- try(qr.solve(h.FE[seq_len(p), seq_len(p)]), silent = !verbose)
                      if (inherits(vb, "try-error")) 
                        stop(mstyle$stop(paste0("Cannot invert Hessian for the ", ifelse(method == "T0", "ML", method), " model.")))
                    }
                    else {
                      vb <- chol2inv(chol.h)
                    }
                  }
                  if (is.element(optimizer, c("clogit", "clogistic"))) {
                    beta <- cbind(coef(res.FE)[seq_len(p)])
                    vb <- vcov(res.FE)[seq_len(p), seq_len(p), drop = FALSE]
                  }
                  tau2 <- 0
                  sigma2 <- NA
                  parms <- p
                  p.eff <- p
                  k.eff <- k
                }
                if (method == "ML") {
                  beta <- cbind(res.ML$par[seq_len(p)])
                  chol.h <- try(chol(h.ML), silent = !verbose)
                  if (inherits(chol.h, "try-error") || anyNA(chol.h)) {
                    if (anyNA(chol.h)) 
                      stop(mstyle$stop("Cannot invert Hessian for the ML model."))
                    warning(mstyle$warning("Choleski factorization of Hessian failed. Trying inversion via QR decomposition."), call. = FALSE)
                    vb.f <- try(qr.solve(h.ML), silent = !verbose)
                    if (inherits(vb.f, "try-error")) 
                      stop(mstyle$stop("Cannot invert Hessian for the ML model."))
                  }
                  else {
                    vb.f <- chol2inv(chol.h)
                  }
                  vb <- vb.f[seq_len(p), seq_len(p), drop = FALSE]
                  if (any(diag(vb) <= 0)) 
                    stop(mstyle$stop("Cannot compute var-cov matrix of the fixed effects."))
                  tau2 <- exp(res.ML$par[p + 1])
                  sigma2 <- NA
                  parms <- p + 1
                  p.eff <- p
                  k.eff <- k
                  if (vb.f[p + 1, p + 1] >= 0) {
                    se.tau2 <- sqrt(vb.f[p + 1, p + 1]) * tau2
                    crit <- qnorm(level/2, lower.tail = FALSE)
                    ci.lb.tau2 <- exp(res.ML$par[p + 1] - crit * sqrt(vb.f[p + 1, p + 1]))
                    ci.ub.tau2 <- exp(res.ML$par[p + 1] + crit * sqrt(vb.f[p + 1, p + 1]))
                  }
                }
                if (is.element(method, c("ML", "T0"))) {
                  tmp <- try(rma.uni(measure = "PETO", ai = ai, bi = bi, ci = ci, di = di, add = 0, mods = X.fit, intercept = FALSE, skipr2 = TRUE), silent = TRUE)
                  if (!inherits(tmp, "try-error")) {
                    gvar1 <- det(vcov(tmp))
                    gvar2 <- det(vb)
                    ratio <- (gvar1/gvar2)^(1/(2 * m))
                    if (!is.na(ratio) && ratio >= 100) {
                      warning(mstyle$warning("Standard errors of fixed effects appear to be unusually small. Treat results with caution."), call. = FALSE)
                      se.warn <- TRUE
                    }
                    if (!is.na(ratio) && ratio <= 1/100) {
                      warning(mstyle$warning("Standard errors of fixed effects appear to be unusually large. Treat results with caution."), call. = FALSE)
                      se.warn <- TRUE
                    }
                  }
                }
                if (method == "T0") {
                  tau2 <- exp(res.ML$par[p + 1])
                  parms <- p + 1
                  se.tau2 <- 0
                  method <- "ML"
                }
            }
        }
        if (is.element(measure, c("PLO", "PR", "PLN", "IRLN"))) {
            if (is.element(measure, c("PLO", "PR", "PLN"))) {
                dat.grp <- cbind(xi = xi, mi = mi)
                if (is.null(ddd$family)) {
                  if (measure == "PLO") 
                    dat.fam <- binomial(link = link)
                  if (measure == "PR") 
                    dat.fam <- binomial(link = link)
                  if (measure == "PLN") 
                    dat.fam <- binomial(link = link)
                }
                else {
                  dat.fam <- ddd$family
                }
                dat.off <- NULL
            }
            if (is.element(measure, c("IRLN"))) {
                dat.grp <- xi
                if (is.null(ddd$family)) {
                  dat.fam <- poisson(link = link)
                }
                else {
                  dat.fam <- ddd$family
                }
                dat.off <- log(ti)
            }
            study <- factor(seq_len(k))
            X.fit <- X
            if (.isTRUE(ddd$retdat)) 
                return(list(dat.grp = dat.grp, X.fit = X.fit, study = study, dat.off = if (!is.null(dat.off)) dat.off else NULL, dat.fam = dat.fam))
            if (verbose) 
                message(mstyle$message("Fitting FE model ..."))
            res.FE <- try(glm(dat.grp ~ -1 + X.fit, offset = dat.off, family = dat.fam, control = glmCtrl), silent = !verbose)
            if (inherits(res.FE, "try-error")) 
                stop(mstyle$stop(paste0("Cannot fit FE model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))))
            ll.FE <- c(logLik(res.FE))
            QEconv <- FALSE
            ll.QE <- NA
            if (!isTRUE(ddd$skiphet)) {
                if (k > 1 && verbose) 
                  message(mstyle$message("Fitting saturated model ..."))
                if (k > 1) {
                  X.QE <- model.matrix(~-1 + X.fit + study)
                  if (verbose) {
                    res.QE <- try(glm(dat.grp ~ -1 + X.QE, offset = dat.off, family = dat.fam, control = glmCtrl), silent = !verbose)
                  }
                  else {
                    res.QE <- try(suppressWarnings(glm(dat.grp ~ -1 + X.QE, offset = dat.off, family = dat.fam, control = glmCtrl)), silent = !verbose)
                  }
                }
                else {
                  res.QE <- res.FE
                }
                if (inherits(res.QE, "try-error")) {
                  warning(mstyle$warning(paste0("Cannot fit saturated model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))), call. = FALSE)
                }
                else {
                  QEconv <- TRUE
                  ll.QE <- c(logLik(res.QE))
                  b2.QE <- cbind(coef(res.QE, complete = FALSE)[-seq_len(p)])
                  vb2.QE <- vcov(res.QE, complete = FALSE)[-seq_len(p), -seq_len(p), drop = FALSE]
                }
            }
            if (method == "ML") {
                if (verbose) 
                  message(mstyle$message("Fitting ML model ..."))
                if (package == "lme4") {
                  if (verbose) {
                    res.ML <- try(lme4::glmer(dat.grp ~ -1 + X.fit + (1 | study), offset = dat.off, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = do.call(lme4::glmerControl, glmerCtrl)), silent = !verbose)
                  }
                  else {
                    res.ML <- suppressMessages(try(lme4::glmer(dat.grp ~ -1 + X.fit + (1 | study), offset = dat.off, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = do.call(lme4::glmerControl, glmerCtrl)), silent = !verbose))
                  }
                }
                if (package == "GLMMadaptive") {
                  if (is.element(measure, c("PLO", "PR", "PLN"))) {
                    dat.mm <- data.frame(xi = dat.grp[, "xi"], mi = dat.grp[, "mi"], study = study)
                    res.ML <- try(GLMMadaptive::mixed_model(cbind(xi, mi) ~ -1 + X.fit, random = ~1 | study, data = dat.mm, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = glmerCtrl), silent = !verbose)
                  }
                  else {
                    dat.mm <- data.frame(xi = dat.grp, study = study)
                    res.ML <- try(GLMMadaptive::mixed_model(xi ~ -1 + X.fit + offset(dat.off), random = ~1 | study, data = dat.mm, family = dat.fam, nAGQ = nAGQ, verbose = verbose, control = glmerCtrl), silent = !verbose)
                  }
                }
                if (package == "glmmTMB") {
                  if (verbose) {
                    res.ML <- try(glmmTMB::glmmTMB(dat.grp ~ -1 + X.fit + (1 | study), offset = dat.off, family = dat.fam, verbose = verbose, data = NULL, control = do.call(glmmTMB::glmmTMBControl, glmerCtrl)), silent = !verbose)
                  }
                  else {
                    res.ML <- suppressMessages(try(glmmTMB::glmmTMB(dat.grp ~ -1 + X.fit + (1 | study), offset = dat.off, family = dat.fam, verbose = verbose, data = NULL, control = do.call(glmmTMB::glmmTMBControl, glmerCtrl)), silent = !verbose))
                  }
                }
                if (inherits(res.ML, "try-error")) 
                  stop(mstyle$stop(paste0("Cannot fit ML model", ifelse(verbose, ".", " (set 'verbose=TRUE' to obtain further details)."))))
                if (package == "lme4") {
                  ll.ML <- ll.QE - 1/2 * deviance(res.ML)
                }
                else {
                  ll.ML <- c(logLik(res.ML))
                }
            }
            if (is.element(method, c("FE", "EE", "CE"))) {
                beta <- cbind(coef(res.FE)[seq_len(p)])
                vb <- vcov(res.FE)[seq_len(p), seq_len(p), drop = FALSE]
                tau2 <- 0
                sigma2 <- NA
                parms <- p
                p.eff <- p
                k.eff <- k
            }
            if (method == "ML") {
                if (package == "lme4") {
                  beta <- cbind(lme4::fixef(res.ML)[seq_len(p)])
                  vb <- as.matrix(vcov(res.ML))[seq_len(p), seq_len(p), drop = FALSE]
                  tau2 <- lme4::VarCorr(res.ML)[[1]][1]
                }
                if (package == "GLMMadaptive") {
                  beta <- cbind(GLMMadaptive::fixef(res.ML)[seq_len(p)])
                  vb <- as.matrix(vcov(res.ML))[seq_len(p), seq_len(p), drop = FALSE]
                  tau2 <- res.ML$D[1, 1]
                }
                if (package == "glmmTMB") {
                  beta <- cbind(glmmTMB::fixef(res.ML)$cond[seq_len(p)])
                  vb <- as.matrix(vcov(res.ML)$cond)[seq_len(p), seq_len(p), drop = FALSE]
                  tau2 <- glmmTMB::VarCorr(res.ML)[[1]][[1]][[1]]
                }
                sigma2 <- NA
                parms <- p + 1
                p.eff <- p
                k.eff <- k
            }
        }
        if (verbose > 1) 
            message(mstyle$message("Conducting heterogeneity tests ..."))
        if (k > 1 && QEconv) {
            if (!(measure == "OR" && model == "CM.EL" && !is.element(optimizer, c("clogit", "clogistic")))) {
                if (nrow(vb2.QE) > 0) {
                  chol.h <- try(chol(vb2.QE), silent = !verbose)
                  if (inherits(chol.h, "try-error") || anyNA(chol.h)) {
                    warning(mstyle$warning("Cannot invert Hessian for saturated model."), call. = FALSE)
                    QE.Wld <- NA
                  }
                  else {
                    QE.Wld <- try(c(t(b2.QE) %*% chol2inv(chol.h) %*% b2.QE), silent = !verbose)
                    if (inherits(QE.Wld, "try-error")) {
                      warning(mstyle$warning("Cannot invert Hessian for saturated model."), call. = FALSE)
                      QE.Wld <- NA
                    }
                  }
                }
                else {
                  QE.Wld <- 0
                }
            }
            QE.LRT <- -2 * (ll.FE - ll.QE)
            QE.Wld[QE.Wld <= 0] <- 0
            QE.LRT[QE.LRT <= 0] <- 0
            QE.df <- k - p
            if (QE.df > 0) {
                QEp.Wld <- pchisq(QE.Wld, df = QE.df, lower.tail = FALSE)
                QEp.LRT <- pchisq(QE.LRT, df = QE.df, lower.tail = FALSE)
            }
            else {
                QEp.Wld <- 1
                QEp.LRT <- 1
            }
        }
        else {
            QE.Wld <- NA
            QE.LRT <- NA
            QEp.Wld <- NA
            QEp.LRT <- NA
            QE.df <- NA
        }
        wi <- 1/vi
        W <- diag(wi, nrow = k.yi, ncol = k.yi)
        stXWX <- .invcalc(X = X.yi, W = W, k = k.yi)
        P <- W - W %*% X.yi %*% stXWX %*% crossprod(X.yi, W)
        if (i2def == "1") 
            vt <- (k.yi - p)/.tr(P)
        if (i2def == "2") 
            vt <- 1/mean(wi)
        I2 <- 100 * tau2/(vt + tau2)
        H2 <- tau2/vt + 1
        if (verbose > 1) 
            message(mstyle$message("Conducting tests of the fixed effects ..."))
        chol.h <- try(chol(vb[btt, btt]), silent = !verbose)
        if (inherits(chol.h, "try-error") || anyNA(chol.h)) {
            warning(mstyle$warning("Cannot invert Hessian for QM test."), call. = FALSE)
            QM <- NA
        }
        else {
            QM <- as.vector(t(beta)[btt] %*% chol2inv(chol.h) %*% beta[btt])
        }
        if (!int.only && int.incl && con$scaleX) {
            mX <- rbind(c(intrcpt = 1, -1 * ifelse(is.d[-1], 0, meanX/sdX)), cbind(0, diag(ifelse(is.d[-1], 1, 1/sdX), nrow = length(is.d) - 1, ncol = length(is.d) - 1)))
            beta <- mX %*% beta
            vb <- mX %*% vb %*% t(mX)
            X <- Xsave
        }
        if (test == "t") {
            ddf <- k - p
        }
        else {
            ddf <- NA
        }
        if (.isTRUE(ddd$abbrev)) {
            tmp <- colnames(X)
            tmp <- gsub("relevel(factor(", "", tmp, fixed = TRUE)
            tmp <- gsub("\\), ref = \"[[:alnum:]]*\")", "", tmp)
            tmp <- gsub("poly(", "", tmp, fixed = TRUE)
            tmp <- gsub(", degree = [[:digit:]], raw = TRUE)", "^", tmp)
            tmp <- gsub(", degree = [[:digit:]], raw = T)", "^", tmp)
            tmp <- gsub(", degree = [[:digit:]])", "^", tmp)
            tmp <- gsub("rcs\\([[:alnum:]]*, [[:digit:]]\\)", "", tmp)
            tmp <- gsub("factor(", "", tmp, fixed = TRUE)
            tmp <- gsub("I(", "", tmp, fixed = TRUE)
            tmp <- gsub(")", "", tmp, fixed = TRUE)
            colnames(X) <- tmp
        }
        rownames(beta) <- rownames(vb) <- colnames(vb) <- colnames(X.f) <- colnames(X)
        ve <- diag(vb)
        se <- ifelse(ve >= 0, sqrt(ve), NA)
        names(se) <- NULL
        zval <- c(beta/se)
        if (test == "t") {
            QM <- QM/m
            QMdf <- c(m, k - p)
            QMp <- if (QMdf[2] > 0) 
                pf(QM, df1 = QMdf[1], df2 = QMdf[2], lower.tail = FALSE)
            else NA
            pval <- if (ddf > 0) 
                2 * pt(abs(zval), df = ddf, lower.tail = FALSE)
            else rep(NA, p)
            crit <- if (ddf > 0) 
                qt(level/2, df = ddf, lower.tail = FALSE)
            else rep(NA, p)
        }
        else {
            QMdf <- c(m, NA)
            QMp <- pchisq(QM, df = QMdf[1], lower.tail = FALSE)
            pval <- 2 * pnorm(abs(zval), lower.tail = FALSE)
            crit <- qnorm(level/2, lower.tail = FALSE)
        }
        ci.lb <- c(beta - crit * se)
        ci.ub <- c(beta + crit * se)
        if (verbose > 1) 
            message(mstyle$message("Computing fit statistics and log likelihood ..."))
        ll.ML <- ifelse(is.element(method, c("FE", "EE", "CE")), ll.FE, ll.ML)
        ll.REML <- NA
        dev.ML <- -2 * (ll.ML - ll.QE)
        AIC.ML <- -2 * ll.ML + 2 * parms
        BIC.ML <- -2 * ll.ML + parms * log(k.eff)
        AICc.ML <- -2 * ll.ML + 2 * parms * max(k.eff, parms + 2)/(max(k.eff, parms + 2) - parms - 1)
        dev.REML <- NA
        AIC.REML <- NA
        BIC.REML <- NA
        AICc.REML <- NA
        fit.stats <- matrix(c(ll.ML, dev.ML, AIC.ML, BIC.ML, AICc.ML, ll.REML, dev.REML, AIC.REML, BIC.REML, AICc.REML), ncol = 2, byrow = FALSE)
        dimnames(fit.stats) <- list(c("ll", "dev", "AIC", "BIC", "AICc"), c("ML", "REML"))
        fit.stats <- data.frame(fit.stats)
        if (verbose > 1) 
            message(mstyle$message("Preparing output ..."))
        weighted <- TRUE
        if (is.null(ddd$outlist) || ddd$outlist == "nodata") {
            outdat <- list(ai = ai, bi = bi, ci = ci, di = di, x1i = x1i, x2i = x2i, t1i = t1i, t2i = t2i, xi = xi, mi = mi, ti = ti)
            res <- list(b = beta, beta = beta, se = se, zval = zval, pval = pval, ci.lb = ci.lb, ci.ub = ci.ub, vb = vb, tau2 = tau2, se.tau2 = se.tau2, sigma2 = sigma2, rho = rho, ci.lb.tau2 = ci.lb.tau2, ci.ub.tau2 = ci.ub.tau2, I2 = I2, H2 = H2, vt = vt, QE.Wld = QE.Wld, QEp.Wld = QEp.Wld, QE.LRT = QE.LRT, QEp.LRT = QEp.LRT, QE.df = QE.df, QM = QM, QMdf = QMdf, QMp = QMp, k = k, k.f = k.f, k.yi = k.yi, k.eff = k.eff, k.all = k.all, p = p, p.eff = p.eff, parms = parms, int.only = int.only, int.incl = int.incl, 
                intercept = intercept, yi = yi, vi = vi, X = X, yi.f = yi.f, vi.f = vi.f, X.f = X.f, outdat.f = outdat.f, outdat = outdat, ni = ni, ni.f = ni.f, ids = ids, not.na = not.na, subset = subset, not.na.yivi = not.na.yivi, slab = slab, slab.null = slab.null, measure = measure, method = method, model = model, weighted = weighted, test = test, dfs = ddf, ddf = ddf, btt = btt, m = m, digits = digits, level = level, control = control, verbose = verbose, add = add, to = to, drop00 = drop00, 
                fit.stats = fit.stats, se.warn = se.warn, formula.yi = NULL, formula.mods = formula.mods, version = packageVersion("metafor"), call = mf)
            if (is.null(ddd$outlist)) 
                res <- append(res, list(data = data), which(names(res) == "fit.stats"))
        }
        else {
            if (ddd$outlist == "minimal") {
                res <- list(b = beta, beta = beta, se = se, zval = zval, pval = pval, ci.lb = ci.lb, ci.ub = ci.ub, vb = vb, tau2 = tau2, se.tau2 = se.tau2, sigma2 = sigma2, I2 = I2, H2 = H2, QE.Wld = QE.Wld, QEp.Wld = QEp.Wld, QE.LRT = QE.LRT, QEp.LRT = QEp.LRT, QE.df = QE.df, QEp = QEp, QM = QM, QMdf = QMdf, QMp = QMp, k = k, k.eff = k.eff, p = p, p.eff = p.eff, parms = parms, int.only = int.only, measure = measure, method = method, model = model, test = test, dfs = ddf, ddf = ddf, btt = btt, m = m, 
                  digits = digits, fit.stats = fit.stats)
            }
            else {
                res <- eval(str2lang(paste0("list(", ddd$outlist, ")")))
            }
        }
        if (.isTRUE(ddd$retfit)) {
            res$res.FE <- res.FE
            if (!isTRUE(ddd$skiphet)) 
                res$res.QE <- res.QE
            if (method == "ML") 
                res$res.ML <- res.ML
        }
        time.end <- proc.time()
        res$time <- unname(time.end - time.start)[3]
        if (.isTRUE(ddd$time)) 
            .print.time(res$time)
        if (verbose || .isTRUE(ddd$time)) 
            cat("\n")
        class(res) <- c("rma.glmm", "rma")
        return(res)
    })(xi = c(0, 5, 21, 2, 0, 215), ni = c(50, 48, 250, 459, 109, 4177), measure = "PLO", method = "ML", test = "z", level = 95), time = 0.0889999999999418)
4.4-0
1
FALSE
FALSE
